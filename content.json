{"meta":{"title":"LanSky","subtitle":"时间永不停息，要紧的是思考自己现在能做的事，不浪费每一瞬间。","description":null,"author":"Lanyouhua","url":"http://blog.lansky.me"},"pages":[{"title":"LanSky的小屋","date":"2017-05-14T02:34:44.000Z","updated":"2017-07-04T14:09:39.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.lansky.me/about/index.html","excerpt":"","text":"关于我 90后，喜欢爬山，骑行。 不会游泳，所以每到夏天我都在水上乐园栅栏外发呆。我妈找人给我算过命：少近水。 技术控。喜欢高达， 喜欢跑车。反正越有机器感越强的，却喜欢，更喜欢将自己产品用于生活。 外貌协会。不是看美女，我喜欢看工业艺术， 尤其是技术与艺术的结合，不是冷冰冰的机器，而是作品。 全能控。感觉自己什么都能干，看到什么都想发表自己的意见，恨不得撸起袖子大干一番。典型的冲锋性的人格。 过于追求成就感。 因为成就感能让自己自信心爆棚，所向披靡。 太爱好学习了。 看技术， 看财务，看商业，看心理等等。人生百本书籍计划，只求不断突破，认知升级。 喜欢交朋友。喜欢和朋友一起讨论事情，尤其是头脑风暴，喜欢玩狼人杀。 我的联系方式邮箱：speedsdsd@163.com"}],"posts":[{"title":"HTML5布局的个人总结","slug":"H5-layout-summary","date":"2017-06-04T13:44:34.000Z","updated":"2017-07-04T14:07:06.000Z","comments":true,"path":"2017/06/04/H5-layout-summary/","link":"","permalink":"http://blog.lansky.me/2017/06/04/H5-layout-summary/","excerpt":"","text":"最近应项目的需求，为了更好的支持产品开发。所以针对H5进行了系统学习。本人准备先从基本的布局开始，学习步骤： 布局 =&gt; 润色 =&gt; DOM操作 =&gt; 动画 =&gt; 其他 。 学习主要以Chrome浏览器为主，毕竟人家用户量最多。本人是在阅读大量技术资料，并进行二次消化总结出来的，文章的篇幅略长。 布局的基本属性学习布局之前，需要先了解一个元素到底哪些属性会影响它在界面的形状和位置，这里我总结一下。 属性 备注 width 元素宽度 height 元素高度 margin 边界 padding 内边距 border 边框 left 距离左侧 right 距离右侧 top 距离顶部 bottom 距离底部 就是上面这些基本的元素属性直接控制着元素的形状和位置。那float、display、postion、box-sizing这些属性作用是什么呢？它们存在会间接的影响这些属性最终的作用效果，可以使某些基本属性无效，某些基本属性有效。 基本的默认布局body和html根标签这里先来讨论一下body这个元素。body作为html的主体部分，是整个显示的最底层容器。假设我们给body一个边框样式，并设置高度为100px。 1234body &#123; height: 100px; border: 2px solid black;&#125; 我们发现，body的默认还有8px的margin距离。同时我们也发现，body默认也是块元素，占据整行宽度。 Tips: 这里如果想设置body为占据整个屏幕，而不是跟随内容扩展。则需要将HTML的高度也设为100%。但是在本案例中，如果将body和html高度都设置为100%，会发现右侧出现滚动条的现象。是因为border和margin的会撑开了body的预设的宽度。 盒子模型盒子模型是css当中最重要的概念， 包括margin、padding、border、content。下面的是标准的盒子模型，当然还有IE盒子模型，这里主要以chrome为准，暂不讨论其他浏览器。 从这样图我们看到了，元素的高和宽，是不包括padding和border的。如果设置了元素的padding和border则该元素会撑大所占用的区域。如下图所示 这里我们就能看出来，设置padding和border会撑大元素的范围，如果不想撑大元素的范围的怎么办呢？我们可以使用： 元素的内容的大小变为了200*200的大小了，box-sizing属性的引入使得此元素的内边距和边框不再会增加它的宽度。 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; display属性解读这里我们先来尝试一下默认布局，这里我们只设置width和height属性，其他属性暂不进行设置，这里我们使用div 、p、 a 这三个标签来布局。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;demo&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style type=\"text/css\"&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p style=\"background: orange\"&gt; 比如，Langley（1996) 定义的机器学习是“机器学习是一门人工智能的科学，该领域的主要研究对象是&lt;a href=\"#\" style=\"width: 100px\"&gt;人工智能&lt;/a&gt;，特别是如何在经验学习中改善&lt;a href=\"\"&gt;具体算法&lt;/a&gt;的性能”。 &lt;/p&gt; &lt;p style=\"background: pink\" &gt; 比如，Langley（1996) 定义的机器学习是“机器学习是一门人工智能的科学，该领域的主要研究对象是&lt;a href=\"#\" style=\"width: 100px\"&gt;人工智能&lt;/a&gt;，特别是如何在经验学习中改善&lt;a href=\"\"&gt;具体算法&lt;/a&gt;的性能”。（Machine learning is a science of the artificial. The field's main objects of study are artifacts, specifically algorithms that improve their performance with experience.'） &lt;/p&gt; &lt;p style=\"background: green\" &gt; 比如，Langley（1996) 定义的机器学习是“机器学习是一门人工智能的科学，该领域的主要研究对象是&lt;a href=\"#\" style=\"width: 100px\"&gt;人工智能&lt;/a&gt;，特别是如何在经验学习中改善&lt;a href=\"\"&gt;具体算法&lt;/a&gt;的性能”。（Machine learning is a science of the artificial. The field's main objects of study are artifacts, specifically algorithms that improve their performance with experience.'） &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 显示效果如下图： 这里P标签和a标签表现完全不同布局风格。p标签默认占用整行显示，而a标签就占据行内文本显示的区域。这里p标签就是块元素，a标签就是行内元素。通过设置display属性可以修改当前元素是块元素还是行内元素。下面会详细讲解 块级元素块级元的特点： 总是从新行开始 高度、行高、外边距以及内边距都可以控制 宽度默认是容器的100% 可以容纳内联元素和其他块级元素 块级元素汇总： 块级元素 备注 address 作者信息 blockquote 标签定义块引用 caption 定义表格的标题。在table标签内是块级元素，在外面是行内元素 dl、dt、dd dl定义列表，dt定义项目，dd定义列表 ul、ol、li、 ul 无序列表、ol有序列表、li列表元素 div 通用容器 fieldset、legend 标签将表单内容的一部分打包，生成一组相关表单的字段。legend元素为其表示标题 form 表单元素 h1、h2、h3、h4、h5、h6、 标题元素 hr 水平分割线 p 段落标签 pre pre 元素可定义预格式化的文本。被包围在 pre 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体 table、tbody、td、tfoot、th、thead、tr tbody、tfoot、thead 是分组专用，必须全部使用。使用顺序thead、tfoot、tbody。tr是块级元素。td是行内元素 行内元素行内元素的特点： 和相邻行内元素在一行上 height、width无效，可以通过line-height来设置 设置margin和padding时， 只有左右margin和padding有效，上下margin和padding无效 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其他内联元素 行内元素汇总： 行内元素 备注 a 超链接标签 b 标签规定粗体文本 bdo 元素可覆盖默认的文本方向 big 标签呈现大号字体效果 cite 标签通常表示它所包含的文本对某个参考文献的引用 button 标签按钮，type类型为 submit、reset、button 没有具体语义 br 插入一个简单的换行符 code 标签用于表示计算机源代码或者其他机器可以阅读的文本内容 del 删除元素，默认行内元素 dfn 标签可标记那些对特殊术语或短语的定义 em 标签告诉浏览器把其中的文本表示为强调的内容。 i 标签显示斜体文本效果 iframe 元素会创建包含另外一个文档的内联框架 img 图片链接 input 标签用于搜集用户信息。 ins 标签定义已经被插入文档中的文本，下划线 label 标签为 input 元素定义标注（标记) map 定义一个客户端图像映射。图像映射（image-map）指带有可点击区域的一幅图像 object 定义一个嵌入的对象。 q 标签定义短的引用. 浏览器经常在引用的内容周围添加引号。 select 元素可创建单选或多选菜单 small 标签呈现小号字体效果 span 标签被用来组合文档中的行内元素 strong 用于强调文本，但它强调的程度更强一些 sub 标签可定义下标文本 tt 标签呈现类似打字机或者等宽的文本效果 textarea 标签定义多行的文本输入控件 var 标签表示变量的名称，或者由用户提供的值 var 、code、pre button 发布按钮 button中的type的属性有哪些： button定义可点击按钮 checkbox定义复选框 file定义输入字段和浏览按钮，供文件上传 hidden定义隐藏的输入字段 image定义图像形式的提交按钮 password定义密码字段 radio定义单选按钮 reset定义重置按钮 submit定义提交按钮 text定义单行的输入字段，用户可在其中输入文本 块级元素与行内元素使用float属性解读floatfloat属性用于创建浮动盒， 浮动盒会将元素的左边界或者右边界移动到包含一块或者另一个浮动盒的边界。 left 移动元素，使其左边挨着包含块的左边界，或者另一个浮动元素的右边界 right 移动元素，使其右边界挨着包含块的右边界，或者一个浮动元素的左边界 none 元素位置固定 这里float有很多情况，我们用两个div来描述一下 首先是黄色模块，绿色模块都为float浮动元素。 如下: 这里，因为黄色元素是浮动元素，所以绿色浮动元素紧挨着黄色浮动元素。 黄色不是float元素，绿色是float元素。 如下： 这里绿色还是浮动元素，但是黄色不再是浮动元素了。float属性定义，紧挨着浮动元素边界或者包含块的边界，这里黄色不再是浮动元素，所以绿色在下面并挨着包含块边界。 黄色是float元素，绿色不是float元素。 如下： 这里，绿色非浮动元素竟然在黄色浮动元素下面位置，浮动元素不在独占一行。关于float属性具体解释如下： 因为CSS的float属性，作用是改变块元素对象的默认显示方式。block对象设置了float属性之后，它将不再独自占据一行。可以浮动到左侧或右侧。浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 给元素的float属性赋值后，就是脱离文档流，进行左右浮动，紧贴着父元素(默认为body文本区域)的左右边框。而此浮动元素在文档流空出的位置，由后续的(非浮动)元素填充上去：块级元素直接填充上去，若跟浮动元素的范围发生重叠，浮动元素覆盖块级元素。内联元素：有空隙就插入 设置了float的元素自成一根,类于一个缩小的document,脱离了文档。所以过产生覆盖,除以float最初设计原因—-图文环绕.所以文字不过覆盖,而是环绕，也有例外： 设置了overflow:hidden的元素的文字也不会围绕 ie浏览器中触发了haslayout的元素的文字不会围绕 clearclear元素被用于控制浮动。主要是清除原来的浮动效果。回归文档流模式。存在left、right、both，分别用来清除向左浮动、清除向右浮动、清除左右浮动。 position属性解读staticstatic是默认值。任意position:static; 的元素不会被特殊的定位。一个static元素表示它不会被”positioned”, 一个position属性被设置为其他值的元素表示它会被”positioned”。 relativerelative表示和static一样，除非你添加了一些额外的属性。 在一个相对定位(position属性为relative)的元素上设置top、right、bottom和left属性会使其偏离其正常位置。 注意：其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。 举例： 这里我们看到当内部元素的position属性为relative时，属性top、left、bottom、right属性开始生效。设置其属性为10px,元素发生了偏移。但是下面的元素位置并未跟着发生变化。 当我们设置bottom、right为10px，我们发现，该元素偏移是根据初始所占区域的位置进行偏移。也就是说，不设置top、bottom、left、right值的时候的位置。 fixed一个固定定位(position属性的值为fixed)元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和relative一样，top、right、bottom和left 属性都可用。 一个固定定位元素不会保留它原本在页面应有的空隙(脱离文档流)。 举例： 这里右下角元素Position属性的值为fixed， 该元素的所在范围是以视窗为范围进行布局。脱离原来的文档流。不随着滚动在移动。 absoluteabsolute是最棘手的position值。absolute与fixed的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位(position属性的值为absolute)的元素没有”positioned”祖先元素，那么它是相对于文档的body元素，并且它会随着页面滚动而移动。记住一个”positioned”元素是指position值不是static的元素。 举例： 这里橙色并没有positioned， 所以标记为绿色并且position属性为absolute值的元素会以body为准进行偏移。 这里我们将橙色元素的Position属性改为relative也就是”positioned“, 绿色元素就会相对于橙色元素进行布局。这里我绿色元素的bottom、right都是10px, 则绿色元素位移到了右下角，可以发现absolute元素相对于positioned的祖先元素的布局范围是祖先元素的范围。 所以我们可以看出这postioned的三个属性fixed、absolute、relative在设置left、right、bottom、top的四个属性值时，所参照的范围边界是不同的。 relative 的参照范围是 元素初始位置，也就是并没有设置left、bottom、top、right时的所占区域。 absolute的参考范围是”positioned“的祖先元素所占据的范围，如果没有”positioned“的元素则是body元素,并且脱离了文档流。 fixed的参照范围是整个窗口页面可视区域的范围并且脱离了文档流。 flex高级布局采用Flex布局的元素，称为Flex容器(flex container) ，简称“容器”。 它的所有子元素自动称为容器成员，称为Flex项目,简称“项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴(cross axis)。 主轴的开始位置：(与边框的交叉点)叫做main start, 结束位置叫做main end; 交叉轴的开始位置叫做cross start ，结束位置叫做cross end。 项目默认沿株洲排列。单个项目占据的主轴的空间叫做main size, 占据的交叉轴空间叫做cross size. 容器的属性 flex - direction flex -wrap flex- flow justify-content align-items align-content flex-direction 属性flex-direction 属属性决定主轴的方向(即项目的排列方向)，其属性值： row(默认值)：主轴为水平方向，起点在左端。 12345.box &#123; display: -webkit-flex; display: flex; flex-direction: row;&#125; row-reverse：主轴为水平方向，起点在右端。 演示代码： 12345.box &#123; display: -webkit-flex; display: flex; flex-direction: row-reverse;&#125; column：主轴为垂直方向，起点在上沿。 演示代码： 12345.box &#123; display: -webkit-flex; display: flex; flex-direction: column;&#125; column-reverse：主轴为垂直方向，起点在下沿。 12345.box &#123; display: -webkit-flex; display: flex; flex-direction: column-reverse;&#125; flex - wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。该属性定义，如果一条轴线排不下，如何换行。 可能取三个值： nowrap(默认)：不换行。 wrap:换行，第一个行在上方。 wrap-reverse:换行，第一个行在下方。 前面两个都好理解，最后这个比较难理解，我们来演示看看： 123456.box &#123; display: -webkit-flex; display: flex; flex-direction: row; flex-wrap: wrap-reverse;&#125; 看结果，第一行确实在下面位置。 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。下面是可能取的五个值： flex-start(默认值)：左对齐 123456.box &#123; display: -webkit-flex; display: flex; flex-direction: row; justify-content: flex-start; /*默认值*/&#125; flex-end：右对齐 123456.box &#123; display: -webkit-flex; display: flex; flex-direction: row; justify-content: flex-end;&#125; center：居中 123456.box &#123; display: -webkit-flex; display: flex; flex-direction: row; justify-content: center;&#125; spacing-between：两端对齐，项目之间的间隔相等 123456.box &#123; display: -webkit-flex; display: flex; flex-direction: row; justify-content: space-between;&#125; spacing-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 123456.box &#123; display: -webkit-flex; display: flex; flex-direction: row; justify-content: spacing-around;&#125; align-items属性align-item属性定义项目在交叉轴上如何对齐。可能取的5个值如下： flex-start：交叉轴的起点对齐。 123456789101112131415161718192021222324252627282930.box &#123; border: 2px solid black; display: -webkit-flex; display: flex; flex-direction: row; justify-content: space-around; align-items: flex-start; width: 100%; height: 400px; &#125;.box-item&#123; width: 50px; font-size: 40px; text-align: center; background: orange; margin: 3px;&#125;.box-item:nth-of-type(1)&#123; height: 100px;&#125;.box-item:nth-of-type(2)&#123; height: 50px;&#125;.box-item:nth-of-type(3)&#123; height: 200px;&#125;.box-item:nth-of-type(4)&#123; height: 300px;&#125; 这里为了展示，将几个元素的高度设为不等高，能清除看到效果。 flex-end：交叉轴的终点对齐。 12345678910.box &#123; border: 2px solid black; display: -webkit-flex; display: flex; flex-direction: row; justify-content: space-around; align-items: flex-end; width: 100%; height: 400px; &#125; 这里我将上面的代码中align-items值改为flex-end,其他代码不懂，结果如下： center：交叉轴的中点对齐。 12345678910.box &#123; border: 2px solid black; display: -webkit-flex; display: flex; flex-direction: row; justify-content: space-around; align-items: center; width: 100%; height: 400px; &#125; 同样将上面CSS样式中的align-items改为center，效果如下： baseline：项目的第一行文字的基线对齐。 123456789101112131415161718192021222324252627282930313233 .box &#123;border: 2px solid black;display: -webkit-flex;display: flex;flex-direction: row;justify-content: space-around;align-items: baseline;width: 100%;height: 400px; &#125; .box-item&#123;width: 50px;font-size: 40px;text-align: center;background: orange;margin: 3px; &#125; .box-item:nth-of-type(1)&#123;height: 100px;font-size: 10px; &#125; .box-item:nth-of-type(2)&#123;height: 50px;font-size: 20px; &#125; .box-item:nth-of-type(3)&#123;height: 200px;font-size: 50px; &#125; .box-item:nth-of-type(4)&#123;height: 300px; &#125; 这次我们设置，数字的字体大小不一样，将align-items设置为baseline，结果如下： stretch(默认值)：如果项目未设置高度或设为auto，将占满整个容器。 12345678910111213141516 .box &#123;border: 2px solid black;display: -webkit-flex;display: flex;flex-direction: row;justify-content: space-around;align-items: stretch; &#125; .box-item&#123;width: 50px;/*height: 50px;*/font-size: 40px;text-align: center;background: orange;margin: 3px; &#125; align-content属性align-content属性定义多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：多跟主轴起点对齐。 12345678910111213141516171819 .box &#123; border: 2px solid black; display: -webkit-flex; display: flex; flex-direction: row; flex-wrap: wrap; align-content: flex-start; width: 100%; height: 400px; &#125;.box-item&#123; width: 50px; height: 50px; font-size: 40px; text-align: center; background: orange; margin: 3px;&#125; 这里是我们可以设置了flex-wrap 让当前元素换行，这时候就产生了多根轴线，设置align-content值为flex-start效果如下： flex-end：多根主轴在终点对齐。 12345678910111213141516171819 .box &#123; border: 2px solid black;display: -webkit-flex;display: flex;flex-direction: row;flex-wrap: wrap;align-content: flex-end;width: 100%;height: 400px; &#125; .box-item&#123;width: 50px;height: 50px;font-size: 40px;text-align: center;background: orange;margin: 3px; &#125; 将align-content改为flex-end，效果如下： center：多根主轴在中点对齐。 将上边代码中align-content值改为center,效果如下： space-between：多根主轴两端对齐。 同样，将上面代码改为space-between后的效果： space-around:每个主轴两侧的间隔相等。 将align-content值改为space-around后，效果如下： stretch(默认值)：主轴上所有项目等高度拉伸。 项目的属性 order order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.box-item&#123; order:1 /*默认值为0*/&#125; flex-grow flex-grow 属性定义项目的放大比例，默认为0， 即如果存在剩余空间，也不放大。 123.box-items&#123; flow-grow:1;&#125; flex-shrink flex-shrink属性定义了项目缩小比例，默认为1， 即如果空间不足，该项目将缩小。 如果所有项目的flex-shink属性都为1，当空间不足时，豆浆等比例缩小。如果一个项目的flex-shink属性为0， 其他项目都为1，则空间不足时， 前者不缩小。 flex-basis flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间(main size)浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 1234.box-items&#123; flex-basis:30px; width:300px; /*这里无效*/&#125; 这里我们看到了，当设置了flex-basis之后，原来的width属性无效了，取而代之的是flex-basis参数。它可以设置为width或height属性一样的值(比如350px)，则项目将占据固定空间。 flex flex属性是flex-grow, flex-shrink和flex-basis的简写，默认值为 0 1 auto. 123.box-item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷键:auto (1 1 auto) 和 none (0 0 auto) 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto,表示继承父元素的align-items属性，如果没有父元素则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 响应式布局“响应式布局”，是一种让网站针对不同浏览器和设备“呈现”不同显示效果的策略。 语法媒体查询包含一个可选的媒体类型和零个或者多个满足CSS3规范的表达式。这些表达式描述了媒体特征，最终会被解析为true or false。 两种每次查询的方式： 12&lt;!--link 元素中的CSS媒体查询--&gt;&lt;link rel=\"stylesheet\" media=\"(max-width:600px)\" href=\"./demo.css\" /&gt; 123456/* 在样式列表中使用媒体查询 */@media (max-width:900px)&#123; .static_div &#123; border: 2px solid red; &#125;&#125; 逻辑操作符andand操作符用于合并多个媒体属性或合并媒体属性与媒体类型。 12345@media (max-width:400px) and (max-height:300px) &#123; .static_div &#123; border: 2px solid red; &#125;&#125; 逗号分隔符(or)媒体查询中使用逗号分隔效果等同于or逻辑操作符。当使用逗号分隔的媒体查询时，如何任何一个媒体查询返回真，样式就是有效的。逗号分隔的列表每个查询都是独立的，一个查询中的操作符并不影响其他的媒体查询。这意味着逗号媒体查询列表能够作用于不同的媒体属性、类型和状态。 123456/* 在样式列表中使用媒体查询 */@media (max-width:400px), (max-width:300px) &#123; .static_div &#123; border: 2px solid red; &#125;&#125; notnot 关键字应用于整个媒体查询，在媒体查询为假时返回真。在逗号媒体查询列表中not仅会否定它应用到媒体查询而不影响其他的媒体查询。not关键字仅能用于整个查询，而不能用于一个独立的查询。 12345@media not all and (max-width:200px) &#123; .static_div &#123; border: 2px solid red; &#125;&#125; 等价于： 12345@media not (all and (max-width:200px)) &#123; .static_div &#123; border: 2px solid red; &#125;&#125; 媒体属性通用媒体属性总结如下： 属性 值 是否接受min/max 备注 width length 是 描述了输出设备的渲染区域的宽度 height length 是 描述了输出设备的渲染区域的高度 device-width length 是 描述了输出设备的宽度(整个屏幕或页的宽度，不仅仅是渲染宽度) device-height length 是 描述了输出设备的高度(整个屏幕或页的高度，不仅仅是渲染高度) orientation lanscape\\portrait 否 指定了设备处于横屏,还是竖屏模式。 aspect-ratio ratio 是 描述了输出设备目标显示区域的宽高比 device-aspect-ratio tatio 是 描述了输出设备的宽高比。该值代表两个一个“/”分隔的正整数。 color color 是 指出设备每个像素单元的比特值，如果设备不支持输出颜色，则为零 color-index integer 是 指定了输出设备中颜色查询表中的条目数目 monochrome integer 是 指定了一个黑白(灰度)设备每个像素的比特数。 scan progressive\\interlace 否 描述了电视输出设备的扫描过程。 resolution resolution 是 指定了输出设备的分辨率(像素密度)。分辨率可以用没英寸(dpi)或每厘米(dpcm)的点数来表示。 grid integer 否 判断输出设备是网格还是位图设备。如果设备是基于网格的输出为1，否则为0 手机Web自适应布局总结在移动开发之前，我们首先要做的就是加入以下这段内容： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 作用是将默认的宽度设定为设备的宽度，限制用户缩放屏幕，同时关闭手势缩放功能。 然后要做的就是宽度自适应手机的屏幕。设置width和height的值为100%; 1234div &#123; width:100%; height:100%;&#125; 其次使用REM属性，来设置统一高度等一系列可以用来用px来标注的单位。Rem是相对于根元素设置某个元素的字体大小。 这样就可以根据屏幕宽度大小，修改根元素的字体大小，来调整个界面。 有时候设计师们是在真实的iphone5机器上做的标注，而iphone5系列的分辨率是640，实际上我们在开发只需要按照320的标准来。为了节省时间，不至于每次都需要将标注取半，我们可以将整个网页缩放比例，模拟提高分辨率。这个做法很简单，为不同的设备设置不同的meta即可: 12var scale = 1 / devicePixelRatio;document.querySelector('meta[name=\"viewport\"]').setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); 这种设置同样可以解决安卓机器下1px像素看起来过粗问题。因为在像素为1px的安卓下机器下，边框的1px被压缩成了0.5px了。 还有我们也可以使用媒体查询方式，修改根元素的大小，来自适应布局。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"HTML5","slug":"Technology/HTML5","permalink":"http://blog.lansky.me/categories/Technology/HTML5/"}],"tags":[{"name":"position","slug":"position","permalink":"http://blog.lansky.me/tags/position/"},{"name":"flex","slug":"flex","permalink":"http://blog.lansky.me/tags/flex/"},{"name":"float","slug":"float","permalink":"http://blog.lansky.me/tags/float/"},{"name":"inline-block","slug":"inline-block","permalink":"http://blog.lansky.me/tags/inline-block/"},{"name":"box-sizing","slug":"box-sizing","permalink":"http://blog.lansky.me/tags/box-sizing/"}]},{"title":"iOS客户端网络优化指南","slug":"iOS-client-network","date":"2017-05-19T13:22:50.000Z","updated":"2017-06-27T14:40:46.000Z","comments":true,"path":"2017/05/19/iOS-client-network/","link":"","permalink":"http://blog.lansky.me/2017/05/19/iOS-client-network/","excerpt":"","text":"现在客户端绝大多数的应用都需要进行网络访问，没有网络，手机上的那些应用基本都不能用了。 同时由于手机经常处在不停的移动当中，接收的信号质量和强度也会随之发生变化，继而导致网络访问存在大小时延。如何高效利用网络资源并有效的降低网络流量，迅速把内容展现给用户，确实值得对网络进行优化。最近看了一本书《高性能iOS应用开发》里面提到的内容，进行总结。 在进行网络优化时候，我们需要指标进行衡量，那些指标是影响网络的因素，了解之后，我呢就可以最大成都提高性能。 指标和测量DNS查找时间发起连接的第一步就是DNS查找。查找时间如主DNS服务器的性能成函数关系。最终的连接时与追踪到目的 IP地址的路由成函数关系。 为了最大限度减少DNS查询时间所产生的延迟时间，我们需要遵循以下的最佳实践。 最小化应用使用的专有域名的数量。 身份管理(登录、注销、配置文件) 数据服务(API断点) CDN(图片和其他静态人工产品) 在应用启动时不需要连接所有的域名， 可能只需要身份管理和初始画面所需要的数量。 SSL握手时间苹果提出，上架的应用最好需要支持HTTPS的连接方式。HTTPS在连接开始时，先进行SSL握手，SSL握手主要是验证服务器证书，同时共享用于通信的随机密码。具体流程还是比较耗费时间的。 我们可以遵循以下的方案： 最大程度地减少应用发起的连接数。 请求结束后不要关闭HTTP/S连接。为所有的HTTPS请求添加头Connection：keep-alive.这确保请求可以复用。 使用域分片 网络类型一般情况下，IOS设备可以使用的网络为：WIFI、4G、3G、2G。这里面也就是2G和3G的网速不是很好。3G中尤其是中国TDS_CDMA制式网络最差。所我们在进行网络优化的时候，尤其是要注意低网速环境和弱网环境。比如洗手间、地下室、高铁等等。 所以我们可以着手从以下几个方面考虑优化： 设计时考虑不同的网络可用性。 出现失败时，在随机的、以指数增长的延迟后进行重试。 设立强制刷新之间的最短时间。 使用可到达性库发现网络状态的变化。 不要缓存网络状态。 基于网络类型下载内容。 乐观的预先下载。 如果适用， 当网络可用时，支持同步的离线存储。 延迟延迟是指从服务器请求资源时，在网络传输上花费的额外时间。可以用以下公式来衡量： Round-Trip Time = (Timestamp of Response - Timestamp of Request) Network Latency = Round-Trip Time — Time Spent on Server 就是 适用请求过程中花费的总时间减去服务器上花费的时间。 如果你有数据来分析任何模式下的延迟，还需要考虑： 连接超时 响应超时 载荷大小 网络API在执行任何网络操作时，重要的是你选择的API。 iOS 早期版本提供NSURLConnection 来执行网络请求。现在苹果与iOS7 推出的NSURLSession 是一个更好的选择。具有以下优点： NSURLSession 对于放入其中的相关请求而言是一个可配置的容器。 任何网络任务都可以暂停、停止并重新启动。 你可以继承NSURLSession来配置会话。以便在每个会话的基础上使用专用存储。 当使用NSURLConnection 时，如果遇到身份验证问题，问题会在任何一个请求中返回，你无法明确知道哪个请求遇到了这个问题。使用NSURLSession，委托会处理身份验证。 NSURLSession有一些基于块的异步方法，但委托不能是使用它们。当发起一个请求时，要么成功，要么失败，即使它需要身份验证。 使用NSURLSession，你可以采取一种混合模式的方法。这也就是说，你可以使用基于块的异步方法，还可以设置委托处理身份验证。 应用部署服务器服务器部署上我们可以考虑优化的方向： 使用多个数据中心 使用CDN提供静态内容 使用接近的边缘服务器 避免使用多个域名 请求 为了恰当地设置网络，正确地配置HTTP/S请求很重要。 不要为每一个操作单元都进行一次请求， 使用批量请求。即使必须实现多个后端子系统来完成，但是合并批量请求会带来较大的性能提升，所以还是值得的。客户端可以向多个后端发送多路复用的请求，而服务器可以使用多部分/混合回复作为回应。客户端将对回复进行复用。 使用持续的HTTP连接，该链接也被成为HTTP长连接。有助于最大限度减少TCP和SSL握手的消耗，同时也减少网络拥塞。或者使用WebSockets。 在任何可以的情况下使用HTTP/2。 使用HTTP缓存头设置正确的缓存级别。影响HTTP缓存的响应头是Last-Modified、Expires、ETag和Cache-Control。 数据格式如何你的应用是以数据为导向的，那么选择合适其传输的正确格式很关键。选择格式的时候需要注意： 使用数据压缩。NSURLRequest 会自动在头部添加Accept-Encoding:gzip, deflate。 选择正确的数据格式。原生应用最常用的数据格式正好是JSON和XML。 工具通过使用工具，创建模拟环境并监控某些网络参数，来进一步调整优化网络： 网络链接调节器。他可以模拟不同的网络条件： 入站通信 出站通信 DNS 协议IPv4，IPv6 界面 WiFi、移动。 AT &amp; T 应用资源优化器。 Charles。 网络安全使用HTTPS CRIME攻击。不要使用SSL/TLS压缩。使用 TLS压缩，任何请求都会受到CRIME(Compression Ratio Info-leak Made Easy, 压缩率使信息很容易泄露 )攻击。要想缓解风险，可以关闭TLS压缩，并给每个响应发送反CRIME cookie, 较为简单的方式是发送一个唯一的随机序列cookie. BREACH攻击。如何使用请求/响应正文压缩(Transfer-Encoding=gzip或deflate)，你的通信会受到BREACH(Browser Reconnaissance and Exfiltration via adaptive Compression of Hypertext,通过自使用超文本压缩的浏览器侦听和渗透)攻击。 使用证书锁定 上图显示了中间攻击人的概要，其中中介器拦截来自设备的请求。当设备发送对服务器证书的请求时，中介器将请求发送到服务器并捕获其应答。 这个问题的解决方案就是所谓的证书锁定。工作原理是，通过只信任一个或几个能够作为应用根证书的证书，应用穿件一个自定义信任级别。这个允许应用仅信任来自白名单的证书，确保设备上不安装那些允许网络监视的未知证书。 摘自《高性能iOS应用开发》本书的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990typedef void(^HPResponseHandler)(NSURLResponse *, NSError *error);@interface HPPinnedRequestExecutor @property (nonatomic, readonly) NSURLRequest *request;@property (nonatomic, copy) HPResponseHandler handler;@end@interface HPPinnedRequestExecutor () &lt;NSURLConnectionDelegate&gt; @property (nonatomic, readwrite) NSURLRequest *request;@end@implementation HPPinnedRequestExecutor-(instancetype)initWithRequest:(NSURLRequest *)request &#123; if(self = [super init]) &#123; self.request = request; &#125; return self; &#125;-(void)executeWithHandler:(HPResponseHandler)handler &#123; self.handler = handler; [[NSURLConnection alloc] initWithRequest:self.request delegate:self];&#125;- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; //做常规的事情，用处理器发送结果&#125;//方法检查委托是否能够响应保护空间的身份验证形式，对于SSL(服务器信任)，返回YES.-(BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace*)space &#123; return [NSURLAuthenticationMethodServerTrust isEqualToString:space.authenticationMethod]; &#125;//方法处理challenge, 可以取消认证(无效时)或使用凭证(有效时)- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123; void (^cancel)() = ^&#123; [challenge.sender cancelAuthenticationChallenge:challenge]; &#125;; if([NSURLAuthenticationMethodServerTrust isEqualToString:challenge.protectionSpace.authenticationMethod]) &#123; SecTrustRef serverTrust = challenge.protectionSpace.serverTrust; if(serverTrust == nil) &#123; cancel(); return; &#125; OSStatus status = SecTrustEvaluate(serverTrust, NULL); if(status != errSecSuccess) &#123; cancel(); return; &#125; SecCertificateRef svrCert = SecTrustGetCertificateAtIndex(serverTrust, 0); if(svrCert == nil) &#123; cancel(); return; &#125; CFDataRef svrCertData = SecCertificateCopyData(svrCert); if(svrCertData == nil) &#123; cancel(); return; &#125; const UInt8* const data = CFDataGetBytePtr(svrCertData); const CFIndex size = CFDataGetLength(serverCertificateData); NSData* cert1 = [NSData dataWithBytes:data length:(NSUInteger)size]; if(cert1 == nil) &#123; cancel(); return; &#125; NSString *file = [[NSBundle mainBundle] pathForResource:@\"pinned-key\" ofType:@\"der\"]; NSData* cert2 = [NSData dataWithContentsOfFile:file]; if(cert2 == nil) &#123; cancel(); return; &#125; // 如果发生了失败，则将证书置为无效，与找不到证书，或与绑定的秘钥不匹配。 if(![cert1 isEqualToData:cert2]) &#123; cancel(); return; &#125; [challenge.sender useCredential:[NSURLCredential credentialForTrust:serverTrust] forAuthenticationChallenge:challenge]; &#125;&#125;","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"iOS","slug":"Technology/iOS","permalink":"http://blog.lansky.me/categories/Technology/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.lansky.me/tags/iOS/"},{"name":"NSURLSession","slug":"NSURLSession","permalink":"http://blog.lansky.me/tags/NSURLSession/"}]},{"title":"python学习之面向对象","slug":"Python-object","date":"2017-05-13T01:05:06.000Z","updated":"2017-07-04T13:54:35.000Z","comments":true,"path":"2017/05/13/Python-object/","link":"","permalink":"http://blog.lansky.me/2017/05/13/Python-object/","excerpt":"","text":"在程序设计中最重要的部分就是面向对象的设计思想，这里假设你已经了解什么是面向对象的思想并且能够熟练使用其他语言进行面对对象的编程方式进行编程。这里我只说一下python的面向对象过程。先来看一个典型的python 类结构。 123456789class ClassName(object): \"\"\"docstring for ClassName\"\"\" class_property = '类属性' def __init__(self, arg): super(ClassName, self).__init__() self.arg = arg def obj_method(self): pass 类的基本结构 python所有的类都继承自object 父类。当然也可以不用继承object , 但是你在子类继承调用super时候，会报错。 类定义的下面紧跟着是对该类的描述。 class_property 表示给该类定义类变量，所有的该类的实例化对象共享这个类变量。 __init__初始化函数，作为该类的初始化方法。 super(ClassName, self).__init__() 调用父类的初始化方法，这里self指向该类的实例化的对象。 self.arg = arg给该类实例化的对象添加属性 obj_method(self)该类实例化对象的方法。这里所有的方法都需要添加self，默认self指向实例化对象。 类的基本用法12345678910111213141516171819202122232425262728# '所有动物的基类'class Animation(object): '所有动物的基类' animationCount = 0 def __init__(self, name, age): self.name = name self.age = age; Animation.animationCount += 1 def displayCount(self): print \"Total Animation %d\" % Animation.animationCount def displayAnimation(self): print \"Name : \", self.name, \" age: \", self.age def Test(self): print(self) print(self.__class__) def __del__(self): class_name = self.__class__.__name__ print class_name, \"销毁\" def parentMethod(self): print \"调用父类的方法\" def overrideMethod(self): print \"重写父类的方法，该方法子类重写之后就不在会调用父类的方法\" 实例化对象对象就是类的实例化。 我们实例化上面的类如下： 12345# 实例化类对象animationObj1 = Animation('animationOne', 20000);animationObj2 = Animation('animationTwo', 20000);print 'Total animationCount : ', animationObj2.animationCountanimationObj2.displayAnimation(); 我们看到，animationCount作为类属性，可以被类的实例化对象共享使用。 对象的析构函数在python 一个对象创建必然会调__init__方法。当对象不在被引用的时候，需要释放自己的时候，必然会调用析构函数。 这里的析构函数def __del__(self) 。如果出现该对象内部或者外部存在循环引用，则该对象无法释放，导致内存泄漏。 123def __del__(self): class_name = self.__class__.__name__ print class_name, \"销毁\" 对象的继承和重写面对对象的三大特性：封装、继承和多态。理解并学会合理运用，是提升编程能力的必要条件。 类的继承的特点： 1：在继承中基类的构造（init()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。 2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数 3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 12345678910111213141516171819202122232425class Lion(Animation): \"\"\"子类继承父类Animation\"\"\" __private_Lionheight = '1.2m' def __init__(self, name, age, color): super(Lion, self).__init__(name, age) self.color = color self.__prvate_kind = 'cat' def overrideMethod(self): print \"子类重写了父类，当前调用的是子类方法\" lion = Lion('lion2',20,'orange')print 'lion name', lion.nameprint 'lion color', lion.colorlion.parentMethod()print 'Lion class is sub class : ', issubclass(Lion, Animation)print 'lion obj is sub classs : ', isinstance(lion, Lion)lion.overrideMethod()# print lion.__private_Lionheight # 不能访问# print lion.__prvate_kind #不能访问# Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName 访问属性print lion._Lion__private_Lionheight 输出的结果 12345678910lion name lion2lion color orange调用父类的方法Lion class is sub class : Truelion obj is sub classs : True子类重写了父类，当前调用的是子类方法 repr class name: Lion str class name: Lion11.2m 这里lion.parentMethod()， 调用的是父类Animation的方法。lion.overrideMethod()方法重写了父类的相同的方法。这里调用的是子类的方法。 类的属性和方法在上面的代码中，也看到有的属性我们不能调用，因为被指定为私有属性。python支持私有属性和私有方法。 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 实例的方法 在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 类方法、对象方法、静态方法上面我们已经讨论过了类/对象可以拥有像函数一样的方法，这些对象方法与函数的区别只是一个额外的self变量。 其实python中还有静态方法和类方法。 静态方法要在类中使用静态方法，需要在类成员函数前面加上@staticmethod标记符，以表示下面的成员函数是静态函数。使用静态方法的好处是，不用初始化实例就可以使用这个方法。多个实例共享此静态方法。需要依靠python的修饰器来实现。 类方法一个类方法就可以通过类或它的实例来调用的方法, 不管你是用类来调用这个方法还是类实例调用这个方法,该方法的第一个参数总是定义该方法的类对象。按在惯例，类方法第一个形参被命名为cls.任何时候定义类方法都不是必须的(类方法能实现的功能都可以通过定义一个普通函数来实现,只要这个函数接受一个类对象做为参数就可以了)。 需要依靠python的修饰器来实现。 1234567891011121314151617181920class Animal: def __init__(self, name): self.name=name @staticmethod def sayName(): print 'this is a staticMethod' @classmethod def sayWhat(cls): print 'this is a classMethod'lion = Animal('loin')lion.sayName() # 静态方法，实例可以调用Animal.sayName() # 静态方法，实例也可以直接调用lion.sayWhat() # 类方法，实例可以调用Animal.sayWhat() # 类方法，实例也可以直接调用 基础重载方法下列了一些通用的方法 序号 方法, 描述 &amp; 简单的调用 1 init ( self [,args…] )构造函数简单的调用方法: obj = className(args) 2 del( self )析构方法, 删除一个对象简单的调用方法 : dell obj 3 repr( self )转化为供解释器读取的形式简单的调用方法 : repr(obj) 4 str( self )用于将值转化为适于人阅读的形式简单的调用方法 : str(obj) 5 cmp ( self, x )对象比较简单的调用方法 : cmp(obj, x) 例如: 12345678910111213141516171819class Lion(Animation): ... # 转化为供解释器读取的形式 def __repr__(self): return \" repr class name: %s\" % self.__class__.__name__ def __str__(self): return \" str class name: %s\" % self.__class__.__name__ def __cmp__(self, age): if(self.age &gt; age): return 1 else: return -1# 这里print repr(lion)print str(lion)print cmp(lion, 10) python 内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是’main.className’，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 调用实例如下： 123456789print \"Animation.__doc__:\", Animation.__doc__print \"Animation.__name__:\", Animation.__name__print \"Animation.__module__:\", Animation.__module__print \"Animation.__bases__:\", Animation.__bases__print \"Animation.__dict__:\", Animation.__dict__ 调用结果： 12345678910111213141516171819====================Animation.__doc__: 所有动物的基类Animation.__name__: AnimationAnimation.__module__: __main__Animation.__bases__: (&lt;type &apos;object&apos;&gt;,)Animation.__dict__: &#123;&apos;animationCount&apos;: 2, &apos;__module__&apos;: &apos;__main__&apos;, &apos;displayCount&apos;: &lt;function displayCount at 0x10a5b4d70&gt;, &apos;displayAnimation&apos;: &lt;function displayAnimation at 0x10a5b4de8&gt;, &apos;overrideMethod&apos;: &lt;function overrideMethod at 0x10a5cb050&gt;, &apos;__del__&apos;: &lt;function __del__ at 0x10a5b4ed8&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Animation&apos; objects&gt;, &apos;parentMethod&apos;: &lt;function parentMethod at 0x10a5b4f50&gt;, &apos;Test&apos;: &lt;function Test at 0x10a5b4e60&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Animation&apos; objects&gt;, &apos;__doc__&apos;: &apos;\\xe6\\x89\\x80\\xe6\\x9c\\x89\\xe5\\x8a\\xa8\\xe7\\x89\\xa9\\xe7\\x9a\\x84\\xe5\\x9f\\xba\\xe7\\xb1\\xbb&apos;,&apos;__init__&apos;: &lt;function __init__ at 0x10a4d22a8&gt;&#125;==================== python动态特性：python的类和类累的实例化对象，可以动态的绑定对象及方法。当对对象进行进行绑定时，方法个属性只适用于当前对象。当对类绑定方法和对象时，所有实例的化的对象都可以共享调用。有时候我们的要限制动态添加属性和方法，则可以用__slots__，来指定哪些方法可以动态绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Teacher(object): def __init__(self): pass teacher = Teacher();# 动态添加teacher.name = 'lansky';print 'teacher name',teacher.nameteacher.name = 'lansky2';print 'teacher name',teacher.name# 删除属性# del teacher.nameprint teacher.namefrom types import MethodType# 定义方法def set_age(self, age): self.age = age# 给实例绑定一个方法teacher.set_age = MethodType(set_age, teacher, Teacher) # 调用实例方法teacher.set_age(25) print 'teacher age:', teacher.age # 但是，给一个实例绑定的方法，对另一个实例是不起作用的teacher2 = Teacher()# teacher2.set_age(26)def set_level(self, level): self.level = level # 给class绑定方法后，所有实例均可调用Teacher.set_level = MethodType(set_level, None, Teacher)teacher.set_level(23)print 'teacher level: ', teacher.levelteacher2.set_level(25)print 'teacher level: ', teacher2.levelclass Student(object): \"\"\"docstring for Student\"\"\" __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名student = Student();student.name = \"lansky\"print 'student name :' , student.name# 报错，不允许添加name,age 之外的属性# student.score = 2344 python装饰器Python内置的@property装饰器就是负责把一个方法变成属性调用的： 1234567891011121314class Employee(object): \"\"\"docstring for empt\"\"\" @property def salary(self): return 100 @salary.setter # 如果装饰器不存在，salary 就是只读属性 def salary(self, value): self._score = valueemployee = Employee();print 'employee salary:', employee.salary 获取对象信息type 返回该变量的类型 12345678910111213&gt;&gt;&gt; import types &gt;&gt;&gt; type(123) == types.IntTypeTrue&gt;&gt;&gt; type('abs') == types.StringTypeTrue&gt;&gt;&gt; type([]) == types.ListTypeTrue&gt;&gt;&gt; type(u'abc') == types.UnicodeType True&gt;&gt;&gt; type(&#123;&#125;) == types.DictTypeTrue&gt;&gt;&gt; type(()) == types.TupleTypeTrue isinstance(obj, classname) 判断对象obj 是不是classname的实例化对象 1print 'lion obj is sub classs : ', isinstance(lion, Lion) issubclass(subClass, parentClass) 判断subClass 是不是parentClass的子类 1print 'Lion class is sub class : ', issubclass(Lion, Animation) 小结：python的常用的类语法并不是很难，有编程语言的基础，学习起来并不费劲。这里我简单整理类的常用语法。刚接触python基本功一定要扎实。不知能会写代码，还要能写出简单、高效、易懂 的代码。保证代码稳定、易懂、高效。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"Python","slug":"Technology/Python","permalink":"http://blog.lansky.me/categories/Technology/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.lansky.me/tags/Python/"}]},{"title":"MySQL 之 INSERT TABLE … VALUES …  ON DUPLICATE KEY UP DATE … 用法总结","slug":"Mysql-insert-update","date":"2017-05-07T06:50:03.000Z","updated":"2017-06-27T14:47:35.000Z","comments":true,"path":"2017/05/07/Mysql-insert-update/","link":"","permalink":"http://blog.lansky.me/2017/05/07/Mysql-insert-update/","excerpt":"","text":"​ 向数据库插入记录时，有时会有这种需求，当符合某种条件的数据存在时，去修改它，不存在时，则新增，也就是insertOrUpdate操作。这种控制可以放在业务层，也可以放在数据库层，大多数数据库都支持这种需求，如Oracle的merge语句，再如本文所讲的MySQL中的INSERT … ON DUPLICATE KEY UPDATE语句。 ​ 该语句是基于唯一索引或主键使用，比如一个字段a被加上了unique index，并且表中已经存在了一条记录值为1，下面两个语句会有相同的效果： 12INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1; UPDATE table SET c=c+1 WHERE a=1; ​ ON DUPLICATE KEY UPDATE后面可以放多个字段，用英文逗号分割。使用ON DUPLICATE KEY UPDATE，最终如果插入了一个新行，则受影响的行数是1，如果修改了已存在的一行数据，则受影响的行数是2，如果值不变，则受影响行数是0。 ​ 如果字段b也被加上了unique index，则该语句和下面的update语句是等效的： 1UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1; ​ 如果a=1 OR b=2匹配了多行，则只有一行会被修改。通常的，在ON DUPLICATE KEY UPDATE语句中，我们应该避免多个唯一索引的情况。 ​ 可以在ON DUPLICATE KEY UPDATE后面使用VALUES(字段名)函数来表示即将插入的值，如果需要插入或更新多条数据，并且更新的字段需要根据其它字段来运算时，可以使用如下语句： 12INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6) ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b); ​ 这个语句等同于下面的两个语句： 12INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=3; INSERT INTO table (a,b,c) VALUES (4,5,6) ON DUPLICATE KEY UPDATE c=9;--4+5 ​ 如果一个表中包含了一个自增的字段，使用INSERT … ON DUPLICATE KEY UPDATE新增或修改t数据后，可以通过last_insert_id()方法返回最后自动生成的值，如果是多条，实际测试是返回第一条数据自增的值。 ​ 使用ON DUPLICATE KEY UPDATE时，将忽略DELAYED选项。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"MySQL","slug":"Technology/MySQL","permalink":"http://blog.lansky.me/categories/Technology/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.lansky.me/tags/MySQL/"}]},{"title":"python学习之文件操作","slug":"Python-file-operation","date":"2017-05-07T06:50:03.000Z","updated":"2017-06-27T13:03:36.000Z","comments":true,"path":"2017/05/07/Python-file-operation/","link":"","permalink":"http://blog.lansky.me/2017/05/07/Python-file-operation/","excerpt":"","text":"最近学习了python中关于文件的操作。关于文件及路径的操作，大致可以分为文件的读取和写入、文件及文件夹路径的查找与操作、文件状态的读取操作、 遍历文件夹及文件夹下面的子文件及文件夹。通过这个四个大类的学习，很快我们就能掌握python的文件操作。 ​ 首先我们先来明确一个问题，就是python执行目录和python文件目录。python执行目录是指执行python命令所在的目录。python文件目录是指python代码文件所在目录。其中在写代码使用”.” 这个表示的是python执行所在的目录。 test.py 脚本文件代码: 123456# !/usr/bin/env python# -*- coding: utf-8 -*-import os# 获得当前脚本命名执行的所在目录print os.path.abspath('.') 执行这个python脚本 123# 这里输出是脚本执行所在的路径，而不是脚本文件所在路径。localhost:~lansky$: python /demo/test.py/Users/lansky 使用os.path处理路径提取文件目录中的文件名和文件目录： 12345678910111213141516&gt;&gt;&gt; import os # 提取文件路径中文件名&gt;&gt;&gt; os.path.basename('/User/lan/home/shell.py') # 'shell.py'# 提取文件路径中的文件目录&gt;&gt;&gt; os.path.dirname('/User/lan/home/shell.py')'/User/lan/home'# 把路径分割成dirname和basename，返回一个元组&gt;&gt;&gt; os.path.split('/User/lan/home/shell.py')('/User/lan/home', 'shell.py')# 分割路径，返回路径名和文件扩展名的元组&gt;&gt;&gt; os.path.splitext('/User/lan/home/shell.py')('/User/lan/home/shell', '.py') 使用 os.path模块的 join()函数把目录和文件名拼接在一起： 12&gt;&gt;&gt; os.path.join('/User/lan', 'home/shell.py')'/User/lan/home/shell.py' 检测文件： 123456789101112#路径存在则返回True,路径损坏返回False 支持目录和文件print os.path.exists(__file__) print os.path.getatime(__file__) # 最近访问时间print os.path.getmtime(__file__) # 最近创建时间print os.path.getctime(__file__) # 最近修改时间print os.path.getsize(__file__) # 文件大小print os.path.isfile(__file__) # 是否是文件print os.path.isdir('/User/lan/home') # 是否是目录print os.path.islink(__file__) # 是否是链接print os.path.ismount(__file__) # 是否是挂载点 其他方法： 123456789#获得当前脚本命名执行的所在目录print os.path.abspath('.')#把path中包含的\"~\"和\"~user\"转换成用户目录print os.path.expanduser('~/Destop') #判断目录或文件是否相同print os.path.samefile(__file__, './python_file.py') 文件的读取与写入​ 读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。在python中，读取文件的的对象成为file-like Object。除了file之外， 还可以是内存的字节流， 网络流，自定义流等等。 文件读取要读取一个文件，使用open()函数，传入完整的文件路径和标识符。标识符” r “就是read，表示读取文件。 123&gt;&gt;&gt; fp = open('./pip-selfcheck.json', 'r')&gt;&gt;&gt; print fp&lt;open file './pip-selfcheck.json', mode 'r' at 0x1089325d0&gt; 这里fp 获得了当前文件夹下面的pip-selfcheck.json文件对象， 成功打开文件。然后我们调用fp.read() 一次性读取所有的内容。 123&gt;&gt;&gt; print fp.read()&#123;\"last_check\":\"2017-05-02T14:11:27Z\",\"pypi_version\":\"9.0.1\"&#125;&gt;&gt;&gt; fp.close() 最后，调用fp.close() 关闭文件对象，释放文件资源。如果不释放，文件对象会占占用操作系统的资源。 这里我们要注意，如果文件不存在会抛出IOError, 程序会立即停止。 后面的fp.close()就不会关闭。 app.py文件内容： 12345#!/usr/bin/env python # -*- coding: utf-8 -*-fp = open('./pip-selfcheck.jsons', 'r')print \"文件不存在\"fp.close() 执行结果， 并抛出IOError: 1234Traceback (most recent call last): File &quot;/Users/lanyouhua/Desktop/pythonDemo/app.py&quot;, line 4, in &lt;module&gt; fp = open(&apos;./pip-selfcheck.jsons&apos;, &apos;r&apos;)IOError: [Errno 2] No such file or directory: &apos;./pip-selfcheck.jsons&apos; 使用read() 函数，会一次读取全部内容。如果文件很多，内存很容易就被被塞满了。 所以提供了read(size)函数，读取size单位为Bytes. 如果不指定就会读取全部内容。如果读取的是文本内容，可以使用readlines()一次性读取多行内容。 文件写入写文件与读文件一样，都要调用open()函数，只不过标示符采用的是”w”, 表示写文件。这里的路径如果是当前执行脚本所在目录下面文件可以直接创建，如果有子目录就不抛出错误IOError。 12345fp = open('./test.txt', 'w')fp.write(\"hello world\");fp.close() # 关闭之后从新打开文件，并读取内容fp = open('./test.txt', 'r')print fp.read() 这里要注意，当我们写文件时，操作系统旺旺不会立即把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把内有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写到一部分，剩下的全部丢失。 所以可以使用with语句来避免这种问题。 快捷方式with 对一些内建的对象进行了改进，加入了上下文管理器的支持，可以用于with语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。这里我们只用它来自动关闭文件的功能。 改进代码： 12345with open('./test.txt', 'w') as fp: fp.write(\"hello world, by with\");with open('./test.txt', 'r') as fp: print fp.read() 使用with 之后，就不需要手动关闭打开的文件，它会自动帮我们释放占有的文件资源。 二进制文件之前我们都是读取的文本文本，并且是UTF-8编码的文本文件，要读取视频，图片， 音频等二进制文件，需要在表示后面机上”b”, 例如读二进制文件”rb”. 123&gt;&gt;&gt; f = open('./test.png', 'rb')&gt;&gt;&gt; f.read()'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\... 常用的文件标示符： 文件标示符 函数 w 以写方式打开 a 以追加模式打开 r+ 以读写模式打开 w+ 以读写模式打开 a+ 以读写模式打开 rb 以二进制读模式打开 wb 以二进制写模式打开 ab 以二进制追加模式打开 rb+ 以二进制读写模式打开 wb+ 以二进制读写模式打开 ab+ 以二进制读写模式打开 字符编码问题要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件: 1234f = open('./gbk.txt', 'rb')u = f.read().decode('gbk')print u# u'\\u6d4b\\u8bd5' 文件夹的操作文件夹的创建python 文件夹的创建是在os模块的mkdir()和makedirs()两个函数，后者支持递归创建。 12345# 创建文件夹,不能递归print os.mkdir('./createFoloder')# 递归创建文件夹 the default mode 0777print os.makedirs('./test_parent/test_sub') 文件夹的删除python 文件夹的删除是在os模块的rmdir()和removedirs()两个函数，后者支持递归删除。 1234# 删除文件夹，不能递归删除文件夹print os.rmdir('./createFoloder')# 递归删除文件夹print os.removedirs('./test_parent/test_sub') 文件夹的遍历os.path模块提供了文件遍历的方法，只需要提供回调函数，遍历文件路径，就可以快速遍历文件夹下面的文件。 123456def visit(arg, dirname, names): print 'dirname: %s' % dirname # 当前遍历文件目录 print names # 当前遍历目录下面的文件名# 参数 path, callback(arg, dirname, names), argos.path.walk(os.path.realpath('.'), visit, 'a') 列出目录下的文件，可以使用os模块的listdir(path) : 123&gt;&gt;&gt; os.listdir('.')['.Python', 'app.py', 'bin', 'gbk.txt', 'include', 'lib', 'pip-selfcheck.json', 'test.txt', 'test_rename.png', 'test_sub'] 当前环境目录的变更os模块的chdir(path) 可以将当前脚本执行环境切换到任意位置。这个方法很有用，但我们使用os模块的system(commend)函数执行shell命名的时候，可以快速切换shell命名的执行目录。 123456&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.realpath('.')'/Users/lan/Desktop/pythonDemo'&gt;&gt;&gt; os.chdir('../') # 这里改变了 当前修改了当前执行环境的根目录.&gt;&gt;&gt; os.path.realpath('.')'/Users/lan/Desktop' 文件状态读取操作当我们想监控本地文件状态的时候，就需要系统提供的函数 os.stat()函数，他可以返回该文件或者文件夹详细的信息，包括：文件大小、文件最近的访问时间、文件的权限、文件的修改时间、文件的创建时间等常用的信息。 1234567891011import os,time,stat #获取文件/目录的状态 fileStats = os.stat ( './exampleData/test_ignore.txt' ) fileInfo = &#123; 'Size':fileStats [ stat.ST_SIZE ], #获取文件大小 'LastModified':time.ctime( fileStats [ stat.ST_MTIME ] ),#获取文件最后修改时间 'LastAccessed':time.ctime( fileStats [ stat.ST_ATIME ] ),#获取文件最后访问时间 'CreationTime':time.ctime( fileStats [ stat.ST_CTIME ] ),#获取文件创建时间 'Mode':fileStats [ stat.ST_MODE ] #获取文件的模式, 也就是表示权限 &#125; 在文件模式中，还提供了更多的文件信息，如下所示： 1234567891011121314151617181920212223242526#print fileInfo for field in fileInfo: #显示对象内容 print '%s:%s' % (field,fileInfo[field]) if stat.S_ISDIR ( fileStats [ stat.ST_MODE ] ): #判断是否路径 print 'Directory. ' else: print 'Non-directory.' if stat.S_ISREG ( fileStats [ stat.ST_MODE ] ): #判断是否一般文件 print 'Regular file.' elif stat.S_ISLNK ( fileStats [ stat.ST_MODe ] ): #判断是否链接文件 print 'Shortcut.' elif stat.S_ISSOCK ( fileStats [ stat.ST_MODe ] ): #判断是否套接字文件 print 'Socket.' elif stat.S_ISFIFO ( fileStats [ stat.ST_MODe ] ): #判断是否命名管道 print 'Named pipe.' elif stat.S_ISBLK ( fileStats [ stat.ST_MODe ] ): #判断是否块设备 print 'Block special device.' elif stat.S_ISCHR ( fileStats [ stat.ST_MODe ] ): #判断是否字符设置 print 'Character special device.' 执行结果： 1234567LastModified:Mon May 8 20:10:15 2017Mode:33188CreationTime:Mon May 8 20:10:15 2017LastAccessed:Mon May 8 20:10:15 2017Size:0Non-directory.Regular file. shutil 高级文件操作shutil是python 内键模块，支持更高级的文件操作，例如：拷贝文件、移动文件、拷贝删除文件树、拷贝文件权限、拷贝文件信息等等。 shutil模块的中copyfileobj(fsrc, fdst, buffter_size)函数，是根据文件对象进行文件拷贝，buffer_size表示每次读取并写入到目标文件的缓存大小，如果设置太大，会导致内存不可控： 123456789101112131415161718import shutil# 拷贝文件对象src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData/copyfilepbj_result.mp4'fsrc = open(src_file, 'r');fdst = open(dst_file, 'w');# 参数: # 1.目标文件对象# 2.源文件对象# 3.数据缓冲, 如果设置不合理，源文件过大，容易导致不可控的内存消耗# 拷贝文件shutil.copyfileobj(fsrc, fdst, 100);fsrc.close();fdst.close(); 同时，shutil还提供了直接根据文件目录进行拷贝的函数：copyfile(src_file, dst_file)， 这里没有指定缓存大小，所以建议不要拷贝用该函数拷贝太大的文件。 12345src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData/copyfile_result.mp4'# 拷贝文件，这里传入的是文件的完整路径, # 源文件和目标那文件不能是一样的，否则会报错。目标文件的权限必须是可写入的。shutil.copyfile(src_file, dst_file); 在Unix创建文件一个新文件的时候，会根据当前用户的umask接收权限。要把权限从一个文件夹复制到另一个文件，可以使用copymode()函数. 12345678910111213141516src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData/copyfile_result.mp4'print '======= copy_mode before ======='os.chmod(dst_file, 0444);print os.stat(dst_file);# 主要拷贝的文件的权限， 文件的内容，拥有者，组不受影响。 # 目标文件必须存在。shutil.copymode(src_file, dst_file);# 主要拷贝问文件的权限， 最近访问时间，最近修改时间和 标志位。# 拥有者，组不受影响。 目标文件必须存在。shutil.copystat(src_file, dst_file);print '======= copy_mode after ========'print os.stat(dst_file); 执行结果: 123456789101112131415161718192021222324======= copy_mode before =======posix.stat_result(st_mode=33060, st_ino=23458152, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=17723429, st_atime=1494254619, st_mtime=1494254619, st_ctime=1494254619)======= copy_mode after ========posix.stat_result(st_mode=33261, st_ino=23458152, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=17723429, st_atime=1494254619, st_mtime=1494245415, st_ctime=1494254619) 其中st_mode权限改为源文件的权限。其中copystat()函数只拷贝的是文件的权限，coystat()函数拷贝的是文件权限，最近访问时间，修改时间和标志位。 上面提到的拷贝只能拷贝文件，而不能拷贝文件夹，shutil模块的copy()和copy2()函数，支持拷贝文件夹。区别在于copy2()是copy()和copystat()结合。 123456789101112src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData'# 拷贝文件到目标文件或者文件夹，如果是文件夹，# 则目标文件名和源文件名一致。权限位也拷贝。shutil.copy(src_file, dst_file);dst_file = './resultData/copy2_result.mp4'# 和copy很相似， 同时把文件的相关信息也拷贝到目标文件及文件夹，# 相当于同时做了copystat()和copy()操作。shutil.copy2(src_file, dst_file) 当我们需要拷贝文件夹下面的所有的内容时候，上述方法可以实现，但是比较麻烦。shutil模块自带了拷贝文件树的函数：shutil.copytree(src_dir,dst_dir , symlinks=False, ignore=None), 其中 symlink默认是True,就是拷贝连接文件的相关内容，如果改为False则只拷贝文件连接； ignore 后面可以跟上ignore_patterns函数,用户过滤不需要拷贝的文件，例如：shutil.ignore_patterns(&#39;*.txt&#39;)， 不拷贝扩展名为txt的文件。 1234567# shutil.copytree(src, dst, symlinks=False, ignore=None)# symlinks参数控制着符号链接作为链接复制还是文件复制。# ignore 根据ignore_patterns 正则，过滤掉# 默认将内容复制到新文件，如果选项为true，会在目标中创建新的符号链接# 目标文件必须不存在。拷贝的同时会自动创建。# 同时针对文件夹，使用copystat(). 文件使用copy2()shutil.copytree('./exampleData', './resultData2', symlinks=False, ignore=shutil.ignore_patterns('*.txt')) 同时python 也提供了删除整个文件夹的函数：rmtree(path, ignore_errors, onerror) 。path是要删除文件夹路径， ignore_errors表示如果出现了某写文件被系统其他任务占用无法删除，是够忽略错误， 如果为False，遇到错误直接抛出异常。onerror 表示错误回调处理。 123456789# shutil.rmtree(path, ignore_errors, onerror)# 参数：ignore_errors 移除失败，是否忽略错误，否则报错。# 提供oneerror 接收三个参数：function，path， execinfo# function 处理异常错误 可能是# os.path.islink(), os.listdir(), os.remove() or os.rmdir()# path 文件路径# 额外信息 有 sys.excinfo() 返回# 发生错误才会调用shutil.rmtree('./resultData2',True); 小结python 相比较C/C++等语言， 本身提供大量了好用的、便捷的函数给开发者，让开发者只关注业务逻辑而不是语言本身及算法。给开发者节省了大量的时间，这里只是介绍文件处理相关操作。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"Python","slug":"Technology/Python","permalink":"http://blog.lansky.me/categories/Technology/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.lansky.me/tags/Python/"}]}]}