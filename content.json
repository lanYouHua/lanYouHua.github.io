{"meta":{"title":"LanSky","subtitle":"时间永不停息，要紧的是思考自己现在能做的事，不浪费每一瞬间。","description":null,"author":"Lanyouhua","url":"http://blog.lansky.me"},"pages":[{"title":"LanSky的小屋","date":"2017-05-14T02:34:44.000Z","updated":"2017-05-19T14:45:10.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.lansky.me/about/index.html","excerpt":"","text":"关于我 90后，喜欢爬山，骑行。 不会游泳，所以每到夏天我都在水上乐园栅栏外发呆。我妈找人给我算过命：少近水。 技术控。喜欢高达， 喜欢跑车。反正越有机器感越强的，却喜欢，更喜欢将自己产品用于生活。 外貌协会。不是看美女，我喜欢看工业艺术， 尤其是技术与艺术的结合，不是冷冰冰的机器，而是作品。 全能控。感觉自己什么都能干，看到什么都想发表自己的意见，恨不得撸起袖子大干一番。典型的冲锋性的人格。 过于追求成就感。 因为成就感能让自己自信心爆棚，所向披靡。 太特么爱好学习了。 看技术， 看财务，看商业，看心理等等。人生百本书籍计划，只求不断突破，认知升级。 喜欢交朋友。喜欢和朋友一起讨论事情，尤其是头脑风暴，喜欢玩狼人杀。 我的技能 我的联系方式邮箱：speedsdsd@163.com"}],"posts":[{"title":"iOS客户端网络优化指南","slug":"2017-05-19-iOS-client-network","date":"2017-05-19T13:22:50.000Z","updated":"2017-05-19T14:24:41.000Z","comments":true,"path":"2017/05/19/2017-05-19-iOS-client-network/","link":"","permalink":"http://blog.lansky.me/2017/05/19/2017-05-19-iOS-client-network/","excerpt":"","text":"现在客户端绝大多数的应用都需要进行网络访问，没有网络，手机上的那些应用基本都不能用了。 同时由于手机经常处在不停的移动当中，接收的信号质量和强度也会随之发生变化，继而导致网络访问存在大小时延。如何高效利用网络资源并有效的降低网络流量，迅速把内容展现给用户，确实值得对网络进行优化。最近看了一本书《高性能iOS应用开发》里面提到的内容，进行总结。 在进行网络优化时候，我们需要指标进行衡量，那些指标是影响网络的因素，了解之后，我呢就可以最大成都提高性能。 指标和测量DNS查找时间发起连接的第一步就是DNS查找。查找时间如主DNS服务器的性能成函数关系。最终的连接时与追踪到目的 IP地址的路由成函数关系。 为了最大限度减少DNS查询时间所产生的延迟时间，我们需要遵循以下的最佳实践。 最小化应用使用的专有域名的数量。 身份管理(登录、注销、配置文件) 数据服务(API断点) CDN(图片和其他静态人工产品) 在应用启动时不需要连接所有的域名， 可能只需要身份管理和初始画面所需要的数量。 SSL握手时间苹果提出，上架的应用最好需要支持HTTPS的连接方式。HTTPS在连接开始时，先进行SSL握手，SSL握手主要是验证服务器证书，同时共享用于通信的随机密码。具体流程还是比较耗费时间的。 我们可以遵循以下的方案： 最大程度地减少应用发起的连接数。 请求结束后不要关闭HTTP/S连接。为所有的HTTPS请求添加头Connection：keep-alive.这确保请求可以复用。 使用域分片 网络类型一般情况下，IOS设备可以使用的网络为：WIFI、4G、3G、2G。这里面也就是2G和3G的网速不是很好。3G中尤其是中国TDS_CDMA制式网络最差。所我们在进行网络优化的时候，尤其是要注意低网速环境和弱网环境。比如洗手间、地下室、高铁等等。 所以我们可以着手从以下几个方面考虑优化： 设计时考虑不同的网络可用性。 出现失败时，在随机的、以指数增长的延迟后进行重试。 设立强制刷新之间的最短时间。 使用可到达性库发现网络状态的变化。 不要缓存网络状态。 基于网络类型下载内容。 乐观的预先下载。 如果适用， 当网络可用时，支持同步的离线存储。 延迟延迟是指从服务器请求资源时，在网络传输上花费的额外时间。可以用以下公式来衡量： Round-Trip Time = (Timestamp of Response - Timestamp of Request) Network Latency = Round-Trip Time — Time Spent on Server 就是 适用请求过程中花费的总时间减去服务器上花费的时间。 如果你有数据来分析任何模式下的延迟，还需要考虑： 连接超时 响应超时 载荷大小 网络API在执行任何网络操作时，重要的是你选择的API。 iOS 早期版本提供NSURLConnection 来执行网络请求。现在苹果与iOS7 推出的NSURLSession 是一个更好的选择。具有以下优点： NSURLSession 对于放入其中的相关请求而言是一个可配置的容器。 任何网络任务都可以暂停、停止并重新启动。 你可以继承NSURLSession来配置会话。以便在每个会话的基础上使用专用存储。 当使用NSURLConnection 时，如果遇到身份验证问题，问题会在任何一个请求中返回，你无法明确知道哪个请求遇到了这个问题。使用NSURLSession，委托会处理身份验证。 NSURLSession有一些基于块的异步方法，但委托不能是使用它们。当发起一个请求时，要么成功，要么失败，即使它需要身份验证。 使用NSURLSession，你可以采取一种混合模式的方法。这也就是说，你可以使用基于块的异步方法，还可以设置委托处理身份验证。 应用部署服务器服务器部署上我们可以考虑优化的方向： 使用多个数据中心 使用CDN提供静态内容 使用接近的边缘服务器 避免使用多个域名 请求 为了恰当地设置网络，正确地配置HTTP/S请求很重要。 不要为每一个操作单元都进行一次请求， 使用批量请求。即使必须实现多个后端子系统来完成，但是合并批量请求会带来较大的性能提升，所以还是值得的。客户端可以向多个后端发送多路复用的请求，而服务器可以使用多部分/混合回复作为回应。客户端将对回复进行复用。 使用持续的HTTP连接，该链接也被成为HTTP长连接。有助于最大限度减少TCP和SSL握手的消耗，同时也减少网络拥塞。或者使用WebSockets。 在任何可以的情况下使用HTTP/2。 使用HTTP缓存头设置正确的缓存级别。影响HTTP缓存的响应头是Last-Modified、Expires、ETag和Cache-Control。 数据格式如何你的应用是以数据为导向的，那么选择合适其传输的正确格式很关键。选择格式的时候需要注意： 使用数据压缩。NSURLRequest 会自动在头部添加Accept-Encoding:gzip, deflate。 选择正确的数据格式。原生应用最常用的数据格式正好是JSON和XML。 工具通过使用工具，创建模拟环境并监控某些网络参数，来进一步调整优化网络： 网络链接调节器。他可以模拟不同的网络条件： 入站通信 出站通信 DNS 协议IPv4，IPv6 界面 WiFi、移动。 AT &amp; T 应用资源优化器。 Charles。 网络安全使用HTTPS CRIME攻击。不要使用SSL/TLS压缩。使用 TLS压缩，任何请求都会受到CRIME(Compression Ratio Info-leak Made Easy, 压缩率使信息很容易泄露 )攻击。要想缓解风险，可以关闭TLS压缩，并给每个响应发送反CRIME cookie, 较为简单的方式是发送一个唯一的随机序列cookie. BREACH攻击。如何使用请求/响应正文压缩(Transfer-Encoding=gzip或deflate)，你的通信会受到BREACH(Browser Reconnaissance and Exfiltration via adaptive Compression of Hypertext,通过自使用超文本压缩的浏览器侦听和渗透)攻击。 使用证书锁定 上图显示了中间攻击人的概要，其中中介器拦截来自设备的请求。当设备发送对服务器证书的请求时，中介器将请求发送到服务器并捕获其应答。 这个问题的解决方案就是所谓的证书锁定。工作原理是，通过只信任一个或几个能够作为应用根证书的证书，应用穿件一个自定义信任级别。这个允许应用仅信任来自白名单的证书，确保设备上不安装那些允许网络监视的未知证书。 摘自《高性能iOS应用开发》本书的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990typedef void(^HPResponseHandler)(NSURLResponse *, NSError *error);@interface HPPinnedRequestExecutor @property (nonatomic, readonly) NSURLRequest *request;@property (nonatomic, copy) HPResponseHandler handler;@end@interface HPPinnedRequestExecutor () &lt;NSURLConnectionDelegate&gt; @property (nonatomic, readwrite) NSURLRequest *request;@end@implementation HPPinnedRequestExecutor-(instancetype)initWithRequest:(NSURLRequest *)request &#123; if(self = [super init]) &#123; self.request = request; &#125; return self; &#125;-(void)executeWithHandler:(HPResponseHandler)handler &#123; self.handler = handler; [[NSURLConnection alloc] initWithRequest:self.request delegate:self];&#125;- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; //做常规的事情，用处理器发送结果&#125;//方法检查委托是否能够响应保护空间的身份验证形式，对于SSL(服务器信任)，返回YES.-(BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace*)space &#123; return [NSURLAuthenticationMethodServerTrust isEqualToString:space.authenticationMethod]; &#125;//方法处理challenge, 可以取消认证(无效时)或使用凭证(有效时)- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123; void (^cancel)() = ^&#123; [challenge.sender cancelAuthenticationChallenge:challenge]; &#125;; if([NSURLAuthenticationMethodServerTrust isEqualToString:challenge.protectionSpace.authenticationMethod]) &#123; SecTrustRef serverTrust = challenge.protectionSpace.serverTrust; if(serverTrust == nil) &#123; cancel(); return; &#125; OSStatus status = SecTrustEvaluate(serverTrust, NULL); if(status != errSecSuccess) &#123; cancel(); return; &#125; SecCertificateRef svrCert = SecTrustGetCertificateAtIndex(serverTrust, 0); if(svrCert == nil) &#123; cancel(); return; &#125; CFDataRef svrCertData = SecCertificateCopyData(svrCert); if(svrCertData == nil) &#123; cancel(); return; &#125; const UInt8* const data = CFDataGetBytePtr(svrCertData); const CFIndex size = CFDataGetLength(serverCertificateData); NSData* cert1 = [NSData dataWithBytes:data length:(NSUInteger)size]; if(cert1 == nil) &#123; cancel(); return; &#125; NSString *file = [[NSBundle mainBundle] pathForResource:@\"pinned-key\" ofType:@\"der\"]; NSData* cert2 = [NSData dataWithContentsOfFile:file]; if(cert2 == nil) &#123; cancel(); return; &#125; // 如果发生了失败，则将证书置为无效，与找不到证书，或与绑定的秘钥不匹配。 if(![cert1 isEqualToData:cert2]) &#123; cancel(); return; &#125; [challenge.sender useCredential:[NSURLCredential credentialForTrust:serverTrust] forAuthenticationChallenge:challenge]; &#125;&#125;","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"iOS","slug":"Technology/iOS","permalink":"http://blog.lansky.me/categories/Technology/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.lansky.me/tags/iOS/"},{"name":"NSURLSession","slug":"NSURLSession","permalink":"http://blog.lansky.me/tags/NSURLSession/"}]},{"title":"python学习之面向对象","slug":"2017-05-13-python-object","date":"2017-05-13T01:05:06.000Z","updated":"2017-05-13T07:08:44.000Z","comments":true,"path":"2017/05/13/2017-05-13-python-object/","link":"","permalink":"http://blog.lansky.me/2017/05/13/2017-05-13-python-object/","excerpt":"","text":"在程序设计中最重要的部分就是面向对象的设计思想，这里假设你已经了解什么是面向对象的思想并且能够熟练使用其他语言进行面对对象的编程方式进行编程。这里我只说一下python的面向对象过程。先来看一个典型的python 类结构。 123456789class ClassName(object): \"\"\"docstring for ClassName\"\"\" class_property = '类属性' def __init__(self, arg): super(ClassName, self).__init__() self.arg = arg def obj_method(self): pass 类的基本结构 python所有的类都继承自object 父类。当然也可以不用继承object , 但是你在子类继承调用super时候，会报错。 类定义的下面紧跟着是对该类的描述。 class_property 表示给该类定义类变量，所有的该类的实例化对象共享这个类变量。 __init__初始化函数，作为该类的初始化方法。 super(ClassName, self).__init__() 调用父类的初始化方法，这里self指向该类的实例化的对象。 self.arg = arg给该类实例化的对象添加属性 obj_method(self)该类实例化对象的方法。这里所有的方法都需要添加self，默认self指向实例化对象。 类的基本用法12345678910111213141516171819202122232425262728# '所有动物的基类'class Animation(object): '所有动物的基类' animationCount = 0 def __init__(self, name, age): self.name = name self.age = age; Animation.animationCount += 1 def displayCount(self): print \"Total Animation %d\" % Animation.animationCount def displayAnimation(self): print \"Name : \", self.name, \" age: \", self.age def Test(self): print(self) print(self.__class__) def __del__(self): class_name = self.__class__.__name__ print class_name, \"销毁\" def parentMethod(self): print \"调用父类的方法\" def overrideMethod(self): print \"重写父类的方法，该方法子类重写之后就不在会调用父类的方法\" 实例化对象对象就是类的实例化。 我们实例化上面的类如下： 12345# 实例化类对象animationObj1 = Animation('animationOne', 20000);animationObj2 = Animation('animationTwo', 20000);print 'Total animationCount : ', animationObj2.animationCountanimationObj2.displayAnimation(); 我们看到，animationCount作为类属性，可以被类的实例化对象共享使用。 对象的析构函数在python 一个对象创建必然会调__init__方法。当对象不在被引用的时候，需要释放自己的时候，必然会调用析构函数。 这里的析构函数def __del__(self) 。如果出现该对象内部或者外部存在循环引用，则该对象无法释放，导致内存泄漏。 123def __del__(self): class_name = self.__class__.__name__ print class_name, \"销毁\" 对象的继承和重写面对对象的三大特性：封装、继承和多态。理解并学会合理运用，是提升编程能力的必要条件。 类的继承的特点： 1：在继承中基类的构造（init()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。 2：在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数 3：Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。 12345678910111213141516171819202122232425class Lion(Animation): \"\"\"子类继承父类Animation\"\"\" __private_Lionheight = '1.2m' def __init__(self, name, age, color): super(Lion, self).__init__(name, age) self.color = color self.__prvate_kind = 'cat' def overrideMethod(self): print \"子类重写了父类，当前调用的是子类方法\" lion = Lion('lion2',20,'orange')print 'lion name', lion.nameprint 'lion color', lion.colorlion.parentMethod()print 'Lion class is sub class : ', issubclass(Lion, Animation)print 'lion obj is sub classs : ', isinstance(lion, Lion)lion.overrideMethod()# print lion.__private_Lionheight # 不能访问# print lion.__prvate_kind #不能访问# Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName 访问属性print lion._Lion__private_Lionheight 输出的结果 12345678910lion name lion2lion color orange调用父类的方法Lion class is sub class : Truelion obj is sub classs : True子类重写了父类，当前调用的是子类方法 repr class name: Lion str class name: Lion11.2m 这里lion.parentMethod()， 调用的是父类Animation的方法。lion.overrideMethod()方法重写了父类的相同的方法。这里调用的是子类的方法。 类的属性和方法在上面的代码中，也看到有的属性我们不能调用，因为被指定为私有属性。python支持私有属性和私有方法。 类的私有属性 __private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs 类的方法 在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数 类的私有方法 __private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.__private_methods 基础重载方法下列了一些通用的方法 序号 方法, 描述 &amp; 简单的调用 1 init ( self [,args…] )构造函数简单的调用方法: obj = className(args) 2 del( self )析构方法, 删除一个对象简单的调用方法 : dell obj 3 repr( self )转化为供解释器读取的形式简单的调用方法 : repr(obj) 4 str( self )用于将值转化为适于人阅读的形式简单的调用方法 : str(obj) 5 cmp ( self, x )对象比较简单的调用方法 : cmp(obj, x) 例如: 12345678910111213141516171819class Lion(Animation): ... # 转化为供解释器读取的形式 def __repr__(self): return \" repr class name: %s\" % self.__class__.__name__ def __str__(self): return \" str class name: %s\" % self.__class__.__name__ def __cmp__(self, age): if(self.age &gt; age): return 1 else: return -1# 这里print repr(lion)print str(lion)print cmp(lion, 10) python 内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是’main.className’，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 调用实例如下： 123456789print \"Animation.__doc__:\", Animation.__doc__print \"Animation.__name__:\", Animation.__name__print \"Animation.__module__:\", Animation.__module__print \"Animation.__bases__:\", Animation.__bases__print \"Animation.__dict__:\", Animation.__dict__ 调用结果： 12345678910111213141516171819====================Animation.__doc__: 所有动物的基类Animation.__name__: AnimationAnimation.__module__: __main__Animation.__bases__: (&lt;type &apos;object&apos;&gt;,)Animation.__dict__: &#123;&apos;animationCount&apos;: 2, &apos;__module__&apos;: &apos;__main__&apos;, &apos;displayCount&apos;: &lt;function displayCount at 0x10a5b4d70&gt;, &apos;displayAnimation&apos;: &lt;function displayAnimation at 0x10a5b4de8&gt;, &apos;overrideMethod&apos;: &lt;function overrideMethod at 0x10a5cb050&gt;, &apos;__del__&apos;: &lt;function __del__ at 0x10a5b4ed8&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Animation&apos; objects&gt;, &apos;parentMethod&apos;: &lt;function parentMethod at 0x10a5b4f50&gt;, &apos;Test&apos;: &lt;function Test at 0x10a5b4e60&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Animation&apos; objects&gt;, &apos;__doc__&apos;: &apos;\\xe6\\x89\\x80\\xe6\\x9c\\x89\\xe5\\x8a\\xa8\\xe7\\x89\\xa9\\xe7\\x9a\\x84\\xe5\\x9f\\xba\\xe7\\xb1\\xbb&apos;,&apos;__init__&apos;: &lt;function __init__ at 0x10a4d22a8&gt;&#125;==================== python动态特性：python的类和类累的实例化对象，可以动态的绑定对象及方法。当对对象进行进行绑定时，方法个属性只适用于当前对象。当对类绑定方法和对象时，所有实例的化的对象都可以共享调用。有时候我们的要限制动态添加属性和方法，则可以用__slots__，来指定哪些方法可以动态绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Teacher(object): def __init__(self): pass teacher = Teacher();# 动态添加teacher.name = 'lansky';print 'teacher name',teacher.nameteacher.name = 'lansky2';print 'teacher name',teacher.name# 删除属性# del teacher.nameprint teacher.namefrom types import MethodType# 定义方法def set_age(self, age): self.age = age# 给实例绑定一个方法teacher.set_age = MethodType(set_age, teacher, Teacher) # 调用实例方法teacher.set_age(25) print 'teacher age:', teacher.age # 但是，给一个实例绑定的方法，对另一个实例是不起作用的teacher2 = Teacher()# teacher2.set_age(26)def set_level(self, level): self.level = level # 给class绑定方法后，所有实例均可调用Teacher.set_level = MethodType(set_level, None, Teacher)teacher.set_level(23)print 'teacher level: ', teacher.levelteacher2.set_level(25)print 'teacher level: ', teacher2.levelclass Student(object): \"\"\"docstring for Student\"\"\" __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名student = Student();student.name = \"lansky\"print 'student name :' , student.name# 报错，不允许添加name,age 之外的属性# student.score = 2344 python装饰器Python内置的@property装饰器就是负责把一个方法变成属性调用的： 1234567891011121314class Employee(object): \"\"\"docstring for empt\"\"\" @property def salary(self): return 100 @salary.setter # 如果装饰器不存在，salary 就是只读属性 def salary(self, value): self._score = valueemployee = Employee();print 'employee salary:', employee.salary 获取对象信息type 返回该变量的类型 12345678910111213&gt;&gt;&gt; import types &gt;&gt;&gt; type(123) == types.IntTypeTrue&gt;&gt;&gt; type('abs') == types.StringTypeTrue&gt;&gt;&gt; type([]) == types.ListTypeTrue&gt;&gt;&gt; type(u'abc') == types.UnicodeType True&gt;&gt;&gt; type(&#123;&#125;) == types.DictTypeTrue&gt;&gt;&gt; type(()) == types.TupleTypeTrue isinstance(obj, classname) 判断对象obj 是不是classname的实例化对象 1print 'lion obj is sub classs : ', isinstance(lion, Lion) issubclass(subClass, parentClass) 判断subClass 是不是parentClass的子类 1print 'Lion class is sub class : ', issubclass(Lion, Animation) 小结：python的常用的类语法并不是很难，有编程语言的基础，学习起来并不费劲。这里我简单整理类的常用语法。刚接触python基本功一定要扎实。不知能会写代码，还要能写出简单、高效、易懂 的代码。保证代码稳定、易懂、高效。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"Python","slug":"Technology/Python","permalink":"http://blog.lansky.me/categories/Technology/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.lansky.me/tags/Python/"}]},{"title":"MySQL 之 INSERT TABLE … VALUES …  ON DUPLICATE KEY UP DATE … 用法总结","slug":"2017-05-06-mysql-insert-update","date":"2017-05-07T06:50:03.000Z","updated":"2017-05-13T06:51:46.000Z","comments":true,"path":"2017/05/07/2017-05-06-mysql-insert-update/","link":"","permalink":"http://blog.lansky.me/2017/05/07/2017-05-06-mysql-insert-update/","excerpt":"","text":"​ 向数据库插入记录时，有时会有这种需求，当符合某种条件的数据存在时，去修改它，不存在时，则新增，也就是insertOrUpdate操作。这种控制可以放在业务层，也可以放在数据库层，大多数数据库都支持这种需求，如Oracle的merge语句，再如本文所讲的MySQL中的INSERT … ON DUPLICATE KEY UPDATE语句。 ​ 该语句是基于唯一索引或主键使用，比如一个字段a被加上了unique index，并且表中已经存在了一条记录值为1，下面两个语句会有相同的效果： 12INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=c+1; UPDATE table SET c=c+1 WHERE a=1; ​ ON DUPLICATE KEY UPDATE后面可以放多个字段，用英文逗号分割。使用ON DUPLICATE KEY UPDATE，最终如果插入了一个新行，则受影响的行数是1，如果修改了已存在的一行数据，则受影响的行数是2，如果值不变，则受影响行数是0。 ​ 如果字段b也被加上了unique index，则该语句和下面的update语句是等效的： 1UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1; ​ 如果a=1 OR b=2匹配了多行，则只有一行会被修改。通常的，在ON DUPLICATE KEY UPDATE语句中，我们应该避免多个唯一索引的情况。 ​ 可以在ON DUPLICATE KEY UPDATE后面使用VALUES(字段名)函数来表示即将插入的值，如果需要插入或更新多条数据，并且更新的字段需要根据其它字段来运算时，可以使用如下语句： 12INSERT INTO table (a,b,c) VALUES (1,2,3),(4,5,6) ON DUPLICATE KEY UPDATE c=VALUES(a)+VALUES(b); ​ 这个语句等同于下面的两个语句： 12INSERT INTO table (a,b,c) VALUES (1,2,3) ON DUPLICATE KEY UPDATE c=3; INSERT INTO table (a,b,c) VALUES (4,5,6) ON DUPLICATE KEY UPDATE c=9;--4+5 ​ 如果一个表中包含了一个自增的字段，使用INSERT … ON DUPLICATE KEY UPDATE新增或修改t数据后，可以通过last_insert_id()方法返回最后自动生成的值，如果是多条，实际测试是返回第一条数据自增的值。 ​ 使用ON DUPLICATE KEY UPDATE时，将忽略DELAYED选项。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"MySQL","slug":"Technology/MySQL","permalink":"http://blog.lansky.me/categories/Technology/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.lansky.me/tags/MySQL/"}]},{"title":"python学习之文件操作","slug":"2017-05-07-python-file-operation","date":"2017-05-07T06:50:03.000Z","updated":"2017-05-13T06:50:39.000Z","comments":true,"path":"2017/05/07/2017-05-07-python-file-operation/","link":"","permalink":"http://blog.lansky.me/2017/05/07/2017-05-07-python-file-operation/","excerpt":"","text":"最近学习了python中关于文件的操作。关于文件及路径的操作，大致可以分为文件的读取和写入、文件及文件夹路径的查找与操作、文件状态的读取操作、 遍历文件夹及文件夹下面的子文件及文件夹。通过这个四个大类的学习，很快我们就能掌握python的文件操作。 ​ 首先我们先来明确一个问题，就是python执行目录和python文件目录。python执行目录是指执行python命令所在的目录。python文件目录是指python代码文件所在目录。其中在写代码使用”.” 这个表示的是python执行所在的目录。 test.py 脚本文件代码: 123456# !/usr/bin/env python# -*- coding: utf-8 -*-import os# 获得当前脚本命名执行的所在目录print os.path.abspath('.') 执行这个python脚本 123# 这里输出是脚本执行所在的路径，而不是脚本文件所在路径。localhost:~lansky$: python /demo/test.py/Users/lansky 使用os.path处理路径提取文件目录中的文件名和文件目录： 12345678910111213141516&gt;&gt;&gt; import os # 提取文件路径中文件名&gt;&gt;&gt; os.path.basename('/User/lan/home/shell.py') # 'shell.py'# 提取文件路径中的文件目录&gt;&gt;&gt; os.path.dirname('/User/lan/home/shell.py')'/User/lan/home'# 把路径分割成dirname和basename，返回一个元组&gt;&gt;&gt; os.path.split('/User/lan/home/shell.py')('/User/lan/home', 'shell.py')# 分割路径，返回路径名和文件扩展名的元组&gt;&gt;&gt; os.path.splitext('/User/lan/home/shell.py')('/User/lan/home/shell', '.py') 使用 os.path模块的 join()函数把目录和文件名拼接在一起： 12&gt;&gt;&gt; os.path.join('/User/lan', 'home/shell.py')'/User/lan/home/shell.py' 检测文件： 123456789101112#路径存在则返回True,路径损坏返回False 支持目录和文件print os.path.exists(__file__) print os.path.getatime(__file__) # 最近访问时间print os.path.getmtime(__file__) # 最近创建时间print os.path.getctime(__file__) # 最近修改时间print os.path.getsize(__file__) # 文件大小print os.path.isfile(__file__) # 是否是文件print os.path.isdir('/User/lan/home') # 是否是目录print os.path.islink(__file__) # 是否是链接print os.path.ismount(__file__) # 是否是挂载点 其他方法： 123456789#获得当前脚本命名执行的所在目录print os.path.abspath('.')#把path中包含的\"~\"和\"~user\"转换成用户目录print os.path.expanduser('~/Destop') #判断目录或文件是否相同print os.path.samefile(__file__, './python_file.py') 文件的读取与写入​ 读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。在python中，读取文件的的对象成为file-like Object。除了file之外， 还可以是内存的字节流， 网络流，自定义流等等。 文件读取要读取一个文件，使用open()函数，传入完整的文件路径和标识符。标识符” r “就是read，表示读取文件。 123&gt;&gt;&gt; fp = open('./pip-selfcheck.json', 'r')&gt;&gt;&gt; print fp&lt;open file './pip-selfcheck.json', mode 'r' at 0x1089325d0&gt; 这里fp 获得了当前文件夹下面的pip-selfcheck.json文件对象， 成功打开文件。然后我们调用fp.read() 一次性读取所有的内容。 123&gt;&gt;&gt; print fp.read()&#123;\"last_check\":\"2017-05-02T14:11:27Z\",\"pypi_version\":\"9.0.1\"&#125;&gt;&gt;&gt; fp.close() 最后，调用fp.close() 关闭文件对象，释放文件资源。如果不释放，文件对象会占占用操作系统的资源。 这里我们要注意，如果文件不存在会抛出IOError, 程序会立即停止。 后面的fp.close()就不会关闭。 app.py文件内容： 12345#!/usr/bin/env python # -*- coding: utf-8 -*-fp = open('./pip-selfcheck.jsons', 'r')print \"文件不存在\"fp.close() 执行结果， 并抛出IOError: 1234Traceback (most recent call last): File &quot;/Users/lanyouhua/Desktop/pythonDemo/app.py&quot;, line 4, in &lt;module&gt; fp = open(&apos;./pip-selfcheck.jsons&apos;, &apos;r&apos;)IOError: [Errno 2] No such file or directory: &apos;./pip-selfcheck.jsons&apos; 使用read() 函数，会一次读取全部内容。如果文件很多，内存很容易就被被塞满了。 所以提供了read(size)函数，读取size单位为Bytes. 如果不指定就会读取全部内容。如果读取的是文本内容，可以使用readlines()一次性读取多行内容。 文件写入写文件与读文件一样，都要调用open()函数，只不过标示符采用的是”w”, 表示写文件。这里的路径如果是当前执行脚本所在目录下面文件可以直接创建，如果有子目录就不抛出错误IOError。 12345fp = open('./test.txt', 'w')fp.write(\"hello world\");fp.close() # 关闭之后从新打开文件，并读取内容fp = open('./test.txt', 'r')print fp.read() 这里要注意，当我们写文件时，操作系统旺旺不会立即把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把内有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写到一部分，剩下的全部丢失。 所以可以使用with语句来避免这种问题。 快捷方式with 对一些内建的对象进行了改进，加入了上下文管理器的支持，可以用于with语句中，比如可以自动关闭文件、线程锁的自动获取和释放等。这里我们只用它来自动关闭文件的功能。 改进代码： 12345with open('./test.txt', 'w') as fp: fp.write(\"hello world, by with\");with open('./test.txt', 'r') as fp: print fp.read() 使用with 之后，就不需要手动关闭打开的文件，它会自动帮我们释放占有的文件资源。 二进制文件之前我们都是读取的文本文本，并且是UTF-8编码的文本文件，要读取视频，图片， 音频等二进制文件，需要在表示后面机上”b”, 例如读二进制文件”rb”. 123&gt;&gt;&gt; f = open('./test.png', 'rb')&gt;&gt;&gt; f.read()'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\... 常用的文件标示符： 文件标示符 函数 w 以写方式打开 a 以追加模式打开 r+ 以读写模式打开 w+ 以读写模式打开 a+ 以读写模式打开 rb 以二进制读模式打开 wb 以二进制写模式打开 ab 以二进制追加模式打开 rb+ 以二进制读写模式打开 wb+ 以二进制读写模式打开 ab+ 以二进制读写模式打开 字符编码问题要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件: 1234f = open('./gbk.txt', 'rb')u = f.read().decode('gbk')print u# u'\\u6d4b\\u8bd5' 文件夹的操作文件夹的创建python 文件夹的创建是在os模块的mkdir()和makedirs()两个函数，后者支持递归创建。 12345# 创建文件夹,不能递归print os.mkdir('./createFoloder')# 递归创建文件夹 the default mode 0777print os.makedirs('./test_parent/test_sub') 文件夹的删除python 文件夹的删除是在os模块的rmdir()和removedirs()两个函数，后者支持递归删除。 1234# 删除文件夹，不能递归删除文件夹print os.rmdir('./createFoloder')# 递归删除文件夹print os.removedirs('./test_parent/test_sub') 文件夹的遍历os.path模块提供了文件遍历的方法，只需要提供回调函数，遍历文件路径，就可以快速遍历文件夹下面的文件。 123456def visit(arg, dirname, names): print 'dirname: %s' % dirname # 当前遍历文件目录 print names # 当前遍历目录下面的文件名# 参数 path, callback(arg, dirname, names), argos.path.walk(os.path.realpath('.'), visit, 'a') 列出目录下的文件，可以使用os模块的listdir(path) : 123&gt;&gt;&gt; os.listdir('.')['.Python', 'app.py', 'bin', 'gbk.txt', 'include', 'lib', 'pip-selfcheck.json', 'test.txt', 'test_rename.png', 'test_sub'] 当前环境目录的变更os模块的chdir(path) 可以将当前脚本执行环境切换到任意位置。这个方法很有用，但我们使用os模块的system(commend)函数执行shell命名的时候，可以快速切换shell命名的执行目录。 123456&gt;&gt;&gt; import os&gt;&gt;&gt; os.path.realpath('.')'/Users/lan/Desktop/pythonDemo'&gt;&gt;&gt; os.chdir('../') # 这里改变了 当前修改了当前执行环境的根目录.&gt;&gt;&gt; os.path.realpath('.')'/Users/lan/Desktop' 文件状态读取操作当我们想监控本地文件状态的时候，就需要系统提供的函数 os.stat()函数，他可以返回该文件或者文件夹详细的信息，包括：文件大小、文件最近的访问时间、文件的权限、文件的修改时间、文件的创建时间等常用的信息。 1234567891011import os,time,stat #获取文件/目录的状态 fileStats = os.stat ( './exampleData/test_ignore.txt' ) fileInfo = &#123; 'Size':fileStats [ stat.ST_SIZE ], #获取文件大小 'LastModified':time.ctime( fileStats [ stat.ST_MTIME ] ),#获取文件最后修改时间 'LastAccessed':time.ctime( fileStats [ stat.ST_ATIME ] ),#获取文件最后访问时间 'CreationTime':time.ctime( fileStats [ stat.ST_CTIME ] ),#获取文件创建时间 'Mode':fileStats [ stat.ST_MODE ] #获取文件的模式, 也就是表示权限 &#125; 在文件模式中，还提供了更多的文件信息，如下所示： 1234567891011121314151617181920212223242526#print fileInfo for field in fileInfo: #显示对象内容 print '%s:%s' % (field,fileInfo[field]) if stat.S_ISDIR ( fileStats [ stat.ST_MODE ] ): #判断是否路径 print 'Directory. ' else: print 'Non-directory.' if stat.S_ISREG ( fileStats [ stat.ST_MODE ] ): #判断是否一般文件 print 'Regular file.' elif stat.S_ISLNK ( fileStats [ stat.ST_MODe ] ): #判断是否链接文件 print 'Shortcut.' elif stat.S_ISSOCK ( fileStats [ stat.ST_MODe ] ): #判断是否套接字文件 print 'Socket.' elif stat.S_ISFIFO ( fileStats [ stat.ST_MODe ] ): #判断是否命名管道 print 'Named pipe.' elif stat.S_ISBLK ( fileStats [ stat.ST_MODe ] ): #判断是否块设备 print 'Block special device.' elif stat.S_ISCHR ( fileStats [ stat.ST_MODe ] ): #判断是否字符设置 print 'Character special device.' 执行结果： 1234567LastModified:Mon May 8 20:10:15 2017Mode:33188CreationTime:Mon May 8 20:10:15 2017LastAccessed:Mon May 8 20:10:15 2017Size:0Non-directory.Regular file. shutil 高级文件操作shutil是python 内键模块，支持更高级的文件操作，例如：拷贝文件、移动文件、拷贝删除文件树、拷贝文件权限、拷贝文件信息等等。 shutil模块的中copyfileobj(fsrc, fdst, buffter_size)函数，是根据文件对象进行文件拷贝，buffer_size表示每次读取并写入到目标文件的缓存大小，如果设置太大，会导致内存不可控： 123456789101112131415161718import shutil# 拷贝文件对象src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData/copyfilepbj_result.mp4'fsrc = open(src_file, 'r');fdst = open(dst_file, 'w');# 参数: # 1.目标文件对象# 2.源文件对象# 3.数据缓冲, 如果设置不合理，源文件过大，容易导致不可控的内存消耗# 拷贝文件shutil.copyfileobj(fsrc, fdst, 100);fsrc.close();fdst.close(); 同时，shutil还提供了直接根据文件目录进行拷贝的函数：copyfile(src_file, dst_file)， 这里没有指定缓存大小，所以建议不要拷贝用该函数拷贝太大的文件。 12345src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData/copyfile_result.mp4'# 拷贝文件，这里传入的是文件的完整路径, # 源文件和目标那文件不能是一样的，否则会报错。目标文件的权限必须是可写入的。shutil.copyfile(src_file, dst_file); 在Unix创建文件一个新文件的时候，会根据当前用户的umask接收权限。要把权限从一个文件夹复制到另一个文件，可以使用copymode()函数. 12345678910111213141516src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData/copyfile_result.mp4'print '======= copy_mode before ======='os.chmod(dst_file, 0444);print os.stat(dst_file);# 主要拷贝的文件的权限， 文件的内容，拥有者，组不受影响。 # 目标文件必须存在。shutil.copymode(src_file, dst_file);# 主要拷贝问文件的权限， 最近访问时间，最近修改时间和 标志位。# 拥有者，组不受影响。 目标文件必须存在。shutil.copystat(src_file, dst_file);print '======= copy_mode after ========'print os.stat(dst_file); 执行结果: 123456789101112131415161718192021222324======= copy_mode before =======posix.stat_result(st_mode=33060, st_ino=23458152, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=17723429, st_atime=1494254619, st_mtime=1494254619, st_ctime=1494254619)======= copy_mode after ========posix.stat_result(st_mode=33261, st_ino=23458152, st_dev=16777220, st_nlink=1, st_uid=501, st_gid=20, st_size=17723429, st_atime=1494254619, st_mtime=1494245415, st_ctime=1494254619) 其中st_mode权限改为源文件的权限。其中copystat()函数只拷贝的是文件的权限，coystat()函数拷贝的是文件权限，最近访问时间，修改时间和标志位。 上面提到的拷贝只能拷贝文件，而不能拷贝文件夹，shutil模块的copy()和copy2()函数，支持拷贝文件夹。区别在于copy2()是copy()和copystat()结合。 123456789101112src_file = './exampleData/test_video.mp4' # 17.7MBdst_file = './resultData'# 拷贝文件到目标文件或者文件夹，如果是文件夹，# 则目标文件名和源文件名一致。权限位也拷贝。shutil.copy(src_file, dst_file);dst_file = './resultData/copy2_result.mp4'# 和copy很相似， 同时把文件的相关信息也拷贝到目标文件及文件夹，# 相当于同时做了copystat()和copy()操作。shutil.copy2(src_file, dst_file) 当我们需要拷贝文件夹下面的所有的内容时候，上述方法可以实现，但是比较麻烦。shutil模块自带了拷贝文件树的函数：shutil.copytree(src_dir,dst_dir , symlinks=False, ignore=None), 其中 symlink默认是True,就是拷贝连接文件的相关内容，如果改为False则只拷贝文件连接； ignore 后面可以跟上ignore_patterns函数,用户过滤不需要拷贝的文件，例如：shutil.ignore_patterns(&#39;*.txt&#39;)， 不拷贝扩展名为txt的文件。 1234567# shutil.copytree(src, dst, symlinks=False, ignore=None)# symlinks参数控制着符号链接作为链接复制还是文件复制。# ignore 根据ignore_patterns 正则，过滤掉# 默认将内容复制到新文件，如果选项为true，会在目标中创建新的符号链接# 目标文件必须不存在。拷贝的同时会自动创建。# 同时针对文件夹，使用copystat(). 文件使用copy2()shutil.copytree('./exampleData', './resultData2', symlinks=False, ignore=shutil.ignore_patterns('*.txt')) 同时python 也提供了删除整个文件夹的函数：rmtree(path, ignore_errors, onerror) 。path是要删除文件夹路径， ignore_errors表示如果出现了某写文件被系统其他任务占用无法删除，是够忽略错误， 如果为False，遇到错误直接抛出异常。onerror 表示错误回调处理。 123456789# shutil.rmtree(path, ignore_errors, onerror)# 参数：ignore_errors 移除失败，是否忽略错误，否则报错。# 提供oneerror 接收三个参数：function，path， execinfo# function 处理异常错误 可能是# os.path.islink(), os.listdir(), os.remove() or os.rmdir()# path 文件路径# 额外信息 有 sys.excinfo() 返回# 发生错误才会调用shutil.rmtree('./resultData2',True); 小结python 相比较C/C++等语言， 本身提供大量了好用的、便捷的函数给开发者，让开发者只关注业务逻辑而不是语言本身及算法。给开发者节省了大量的时间，这里只是介绍文件处理相关操作。","categories":[{"name":"Technology","slug":"Technology","permalink":"http://blog.lansky.me/categories/Technology/"},{"name":"Python","slug":"Technology/Python","permalink":"http://blog.lansky.me/categories/Technology/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://blog.lansky.me/tags/Python/"}]}]}